%%
%% This is file `gabaritmem.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% dms.dtx  (with options: `memoire,gabarit')
%% Example TeX file for the documentation
%% of the jurabib package
%% Copyright (C) 1999, 2000, 2001 Jens Berger
%% See dms.ins  for the copyright details.
%% 
%%% ====================================================================
%%%  @LaTeX-file{
%%%     filename        = "dms.dtx",
%%%     author    = "Nicolas Beauchemin, Damien Rioux-Lavoie, Victor Fardel, Jonathan Godin",
%%%     copyright = "Copyright (C) 2000 , DMS
%%%                  all rights reserved.  Copying of this file is
%%%                  authorized only if either:
%%%                  (1) you make absolutely no changes to your copy,
%%%                  including name; OR
%%%                  (2) if you do make changes, you first rename it
%%%                  to some other name.",
%%%     address   = "Département de Mathématiques et de Statistique",
%%%     telephone = "514-343-6705",
%%%     FAX       = "514-343-5700",
%%%     email     = "aide@dms.umontreal.ca (Internet)",
%%%     keywords  = "latex, amslatex, ams-latex, theorem",
%%%     abstract  = " Ce fichier est un package conçu pour être
%%%                  utilisé avec la version de LaTeX2e 1995/06/01. Il
%%%                  est prévue pour la classe ``amsbook''. Il en
%%%                  modifie le format des pages, l'entête des
%%%                  sections, etc, afin d'être  conforme au modèle de
%%%                  mémoire de maîtrise de l'Université de
%%%                  Montréal. Finalement ce fichier est grandement
%%%                  inspiré du fichier amsclass.dtx.",
%%%     docstring = "The checksum field contains: CRC-16 checksum,
%%%                  word count, line count, and character count, as
%%%                  produced by Robert Solovay's checksum utility."}
%%%  ====================================================================

%% Pour voir les accents de ce fichier, assurez-vous que votre
%% éditeur de texte lise le fichier en utf-8!

%% La classe <dms> est construite au-dessus de <amsbook>, donc
%% <amsmath>, <amsfonts> et <amsthm> sont automatiquement chargés.
%% Pour un mémoire
\documentclass[12pt,twoside,maitrise]{dms}
%% Pour une thèse
%%\documentclass[12pt,twoside,phd]{dms}

\usepackage[utf8]{inputenc} %Obligatoires
\usepackage[T1]{fontenc}    %

%% <lmodern> incorpore les fontes en T1, pour
%% faciliter le dépôt final. Ceci n'est pas la
%% seule option :
%%  1. Si cm-super est installé, vous pouvez enlever <lmodern>
%%     (à ce moment, la police est un peu plus fidèle
%%      au Computer Modern orginal);
%%  2. Si vous avez une police préférée, par exemple,
%%     <times> ou <euler> ou <mathpazo> (et bien d'autres),
%%     alors vous pouvez remplacer <lmodern> ci-bas.
%% Par contre, si vous faîtes face à un problème d'encapsulation
%% lors dépôt final, il se peut que la solution soit d'utiliser <lmodern>.
%% (Parfois le problème est au niveau de l'installation, donc
%%  essayez de compiler sur un autre ordinateur sur lequel vous êtes
%%  certain·e que l'installation est bonne.)
\usepackage{lmodern}
\DeclareSymbolFont{largesymbols}{OMX}{cmex}{m}{n}

%% Il n'est pas nécessaire d'utiliser <babel>, car
%% les commandes intégrées par la classe <dms>
%% \francais et \anglais font le travail. Néanmoins,
%% certains autres packages nécessitent <babel> (comme
%% <natbib>), donc simplement enlever les % devant <babel>
%% dans ce cas. Attention! Certains packages sont sensibles
%% à l'ordre dans lequel ils sont chargés.
%% \francais % or
\anglais
%%
%%\usepackage[english,frenchb]{babel}

 % ENGLISH OPTION
 % If you call \anglais here before the \begin{document},
 % all the chater's header will be in english, even if you
 % call \francais. To change this, use
 % \entetedynamique

%% La commande \sloppy peut avoir des effets étranges sur les
%% lignes de certains paragraphes.  Dans ce cas, essayez \fussy
%% qui suppresse les effets de \sloppy.
%% (\fussy est normalement le comportement par défaut.)
%% On redéfinit \sloppy, pour tenter de réduire les comportements
%% étranges. Le seul changement apporté à la version originale
%% est la valeur de \tolerance.
\def\sloppy{%
  \tolerance 500%  %9999 dans LaTeX ordinaire, mauvaise idée.
  \emergencystretch 3em%
  \hfuzz .5pt
  \vfuzz\hfuzz}
\sloppy   %appel de \sloppy pour le document
%%\fussy  %ou \fussy


%% Packages - START
\usepackage{amsmath,amsfonts,amssymb}

\usepackage{hyperref} % Ajoute les hyperlien
\hypersetup{colorlinks=true,allcolors=black}
\usepackage{hypcap}   % Corrige la position du lien pour les images
\usepackage{bookmark} % Remédie à des petits problème
                      % de <hyperref> (important qu'il
                      % apparaisse APRÈS <hyperref>)
%% pour que la largeur de la légende des figures soit = \textwidth
\usepackage[labelfont=bf, width=\linewidth]{caption}

\usepackage{mathpartir,mdframed,empheq}
%% Config for mdframed
\mdfsetup{%
  innertopmargin=\baselineskip,
  innerbottommargin=\baselineskip,
  skipabove=\baselineskip}
\usepackage{mathtools}
\usepackage{ebproof}
\usepackage{braket} % Easy angle-bracket notation
\usepackage{parskip} %% Skips new paragraph indentation
\usepackage{bbm}
\usepackage{listings} % To typeset code
\lstset{
  basicstyle=\ttfamily,
  mathescape,
  breaklines=true
}

\usepackage{minted} %% Typeset code
\setminted{fontsize=\small}
\usemintedstyle{xcode}

\usepackage{bbold} %% For blackboard font
\usepackage{tikz} %% For drawing diagrams

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt

\usepackage{booktabs} %% Nicer tables
\usepackage{multirow} %% Combines rows and columns in tables
\usepackage{cite}

\usepackage{xspace}

%% Packages - END.

  % Enlever les commentaires du prochaine \hypersetup et
  % le remplir avec l'information pertinente.
  % Ceci ajoute des « méta-données » au pdf.  C'est optionnel,
  % mais recommandé. Vous pouvez voir ces méta-données en
  % ouvrant un visionneur de pdf et en cherchant les propriétés
  % du pdf. (Vous pouvez aussi tapez ' pdfinfo <nom-du-pdf> '
  % dans un terminal.) Ces données sont utiles, par exemple,
  % pour augmenter les chances qu'un algorithme de recherche
  % trouve votre document sur Internet, une fois diffusé.
\hypersetup{
 pdftitle = {Quotients Types in Typer?},
 pdfauthor = {James Tan Juan Whei},
 pdfsubject = {Quotient types},
 pdfkeywords = {dependent types, quotient type}
}

%% Définition des environnements utiles pour un mémoire scientifique.
%% La numérotation est laissée à la discrétion de l'auteur·e. L'exemple
%% illustré ici produit « Définition x.y.z »
%%   x = no. chapitre
%%   y = no. section
%%   z = no. définition
%% et la numérotation des corollaires, définitions, etc. se fait
%% successivement.
%%
%% Les macros \<type>name sont telles qu'ils suivent
%% la langue actuelle. (P.ex. si \francais est utilisé,
%% alors \begin{theo} va faire un Théorème et si \anglais
%% est utilisé, \begin{theo} fera un Theorem.)
%%
\newtheorem{cor}{\corollaryname}[section]
\newtheorem{deff}[cor]{\definitionname}
\newtheorem{ex}[cor]{\examplename}
\newtheorem{lem}[cor]{\lemmaname}
\newtheorem{prop}[cor]{Proposition}
\newtheorem{rem}[cor]{\remarkname}
\newtheorem{theo}[cor]{\theoremname}
\theoremstyle{definition}
\newtheorem{algo}[cor]{\algoname}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
%% NOTE : Il peut être commode de redéfinir \the<type> pour
%% obtenir la numérotation désirée. Par exemple, pour
%% que les corollaires soit numérotés #section.#sous-section.#sous-sous-section.#paragraphe.#corollaire,
%% on fait
%% \renewcommand\thecor{\theparagraph.\arabic{cor}}

%%%
%%% Si vous préférez que les corollaires, définitions, théorèmes,
%%% etc. soient numérotés séparément, utilisez plutôt un bloc de
%%% commandes de la forme :
%%%

%%\newtheorem{cor}{\corollaryname}[section]
%%\newtheorem{deff}{\definitionname}[section]
%%\newtheorem{ex}{\examplename}[section]
%%\newtheorem{lem}{\lemmaname}[section]
%%\newtheorem{prop}{Proposition}[section]
%%\newtheorem{rem}{\remarkname}[section]
%%\newtheorem{theo}{\theoremname}[section]

%%
%% Numérotation des équations par section
%% et des  tableaux et figures par chapitre.
%% Ceci peut être modifié selon les préférences de l'utilisateur.
\numberwithin{equation}{section}
\numberwithin{table}{chapter}
\numberwithin{figure}{chapter}

%%
%% Si on veut faire un index, il faut décommenter la ligne
%% suivante. Ajouter des mots à l'index avec la commande \index{mot cle} au
%% fur et à mesure dans le texte.  Compiler, puis taper la commande
%% makeindex pour creer les indexs.  Après une nouvelle compilation,
%% vous aurez votre index.
%%

%%\makeindex

%% Il est obligatoire d'écrire à double interligne
%% ou à interligne et demi. On peut soit utiliser
%% le package <setspace> ou \baselinestretch.
%% Le package a tendance a créé des grands espaces blancs,
%% le gabarit décourage son utilisation, mais il en
%% reste à la discrétion de l'utilisateur·e.
%% \usepackage[onehalfspacing]{setspace}
 % ou
\renewcommand{\baselinestretch}{1.286} %Interligne et demi (environ 18pt (12pt+6pt) entre les lignes)

%% Other macros and commands
%% Macro to facilitate the definition of variadic macros
%% from https://saswat.padhi.me/blog/2019-09_variadic-macros-in-latex/index.html
%% USAGE :: \VARIADIC {name} {start_sym} {mid_sym} {stop_sym}
\newcommand{\VARIADIC}[4]{%
  \expandafter\newcommand\csname Gobble#1Arg\endcsname[1]{%
    #3##1\csname Check#1Arg\endcsname%
  }%
  \expandafter\newcommand\csname Check#1Arg\endcsname{%
    \csname @ifnextchar\endcsname\bgroup{\csname Gobble#1Arg\endcsname}{#4}%
  }%
  \expandafter\newcommand\csname #1\endcsname[1]{%
    #2##1\csname Check#1Arg\endcsname%
  }%
}

\VARIADIC{Funapp} {} { \ } {} %% Function application by juxtaposition

\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

\newcommand\kw[1] {\textsf{#1}}
\newcommand\id[1] {\texttt{#1}}
\newcommand\fn[1] {\texttt{#1}}
\newcommand\type[1] {\textsf{#1}} %% Type names
\newcommand\latinphrase{\textit}

\NewDocumentCommand{\bI}{}{\mathrm{I}} %% Bold Interval I
\NewDocumentCommand{\ileft}{}{\id{i}_0} %% Interval i0
\NewDocumentCommand{\iright}{}{\id{i}_1} %% Interval i1
\NewDocumentCommand{\refl}{mg}{\IfValueTF{#2}{\kw{refl}_{#1} (#2)}{\kw{refl} (#1)}}

\NewDocumentCommand{\zpair}{}{\mathbb{Z}{\times}\mathbb{Z}{\ne}0}
\NewDocumentCommand{\equalq}{}{equal\mathbb{Q}}
\NewDocumentCommand{\zpairplus}{}{\mathbb{Z}{\times}\mathbb{Z}+}

\NewDocumentCommand{\oftype}{mmg}{\IfValueTF{#3}{#1\vdash#2:#3}{#1:#2}}
\NewDocumentCommand{\eqterm}{mmmg}{\IfValueTF{#4}{#1\vdash#2\equiv#3:#4}{#1\equiv#2:#3}}
\NewDocumentCommand{\eqtype}{mmg}{\IfValueTF{#3}{#1\vdash#2\equiv#3}{#1\equiv#2}}
\NewDocumentCommand{\ctx}{}{\Gamma}
\NewDocumentCommand{\earg}{mg}{\IfValueTF{#2}{#1:=#2}{\_:=#1}} %% Erasable argument

\renewcommand\qed{\blacksquare}

%% Proof assistants
\def\Coq{\textsc{Coq}\xspace}
\def\Agda{\textsc{Agda}\xspace}
\def\Lean{\textsc{Lean}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%                                     %%%%%%%%%%%%%
%%%%%%%%%% D é b u t    d u    d o c u m e n t %%%%%%%%%%%%%
%%%%%%%%%%                                     %%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%
%% Voici des options pour annoter les différentes versions de votre
%% mémoire. La commande \brouillon imprime, au bas de chacune des pages, la
%% date ainsi que l'heure de la dernière compilation de votre fichier.
%%
%%\brouillon
%%
%%
%% \version est la version de votre manuscrit
%%
\version{1}
\pagenumbering{roman}

%%------------------------------------------------- %
%%              pages i et ii                       %
%%------------------------------------------------- %

%%%
%%% Voici les variables à définir pour les deux premières pages de votre
%%% mémoire.
%%%

\title{Quotients Types in Typer}

\author{James Tan Juan Whei}

\copyrightyear{2024}

%% SM: Vraiment?
\department{Département de mathématiques et de statistique}

\date{\today} %Date du DÉPÔT INITIAL (ou du 2e dépôt s'il y a corrections majeures)

\sujet{Discipline}
%%\orientation{orientation}%Ce champ est optionnel
%%
%% Voici les disciplines possibles (voir avec votre directeur):
%% \sujet{statistique},
%% \sujet{mathématiques}, \orientation{mathématiques appliquées},
%% \orientation{mathématiques fondamentales}
%% \orientation{mathématiques de l'ingénieur} et
%% \orientation{mathématiques appliquées}

\president{Nom du président du jury}

\directeur{Nom du directeur de recherche}

%%\codirecteur{Nom du 1er codirecteur}         % s'il y a lieu
%%\codirecteurs{Nom du 2e codirecteur}         % s'il y a lieu

\membrejury{Nom du membre de jury}

%%\examinateur{Nom de l'examinateur externe}   %obligatoire pour la these

%% \membresjury{Deuxième membre du jury}  % s'il y a lieu

%%  \plusmembresjury{Troisième membre du jury}    % s'il y a lieu

 % Cette option existe encore, mais elle n'a plus sa place
 % dans la page titre. L'utiliser seulement si le directeur
 % insiste...
%%\repdoyen{Nom du représentant du doyen} %(thèse seulement)

%%
%% Fin des variables à définir. La commande \maketitle créera votre
%% page titre.

%% Pour mettre bouton qui mène à la page titre
%% dans le visionneur de pdf. Peut être enlever.
\pdfbookmark[chapter]{Couverture}{PageUn}

\maketitle

 % Pour générer la deuxième page titre, il faut appeler à nouveau \maketitle
 % Cette page est obligatoire.
\maketitle

%%------------------------------------------------- %
%%              pages iii                           %
%%------------------------------------------------- %

\francais

\chapter*{Résumé}

...sommaire et mots clés en français...

%%------------------------------------------------- %
%%              pages iv                            %
%%------------------------------------------------- %

\anglais
\chapter*{Abstract}

%% SM: As an "abstract" it's much too dry/detailed/technical, of course.
%%   It's OK if some of your audience won't understand all of the abstract,
%%   but they should all be able to understand at least about half of your
%%   abstract.
%% SM: As a set of contributions, try to "structure" the presentation
%%   to give a feeling for how the different parts relate to each other,
%%   and the relative importance of each one.

This work describes the introduction of quotient types to Typer, a dependently
typed programming language. Quotient types allow programmers to construct new
types based on existing types by redefining the notion of equality for the base
type. This is typically based on equivalence relations defined on the base type;
terms that are \emph{equivalent} according to the relation are thus treated as
equal in the resulting quotient type. For instance, rational numbers may be
defined as the quotient of pairs of integers under an appropriate equivalence
relation. To better accommodate the introduction of quotient types to Typer, we
revamped the built-in equality type by drawing inspiration from cubical type
theory and proof assistants that implement it. As such, Typer's new equality
type is based on functions that have our new interval primitive as an argument.
Such an equality type is more powerful and expressive, it notably lends itself
well to the writing of proofs related to quotient types. In this work, we also
investigate the practicality of the usage of quotient types in a language such
as Typer, both in terms of runtime efficiency and developer-friendliness.
Quotient types do not exist in most modern dependently typed languages,
principally because their usage entails burdensome proof obligations. To
facilitate the usage of quotient types, we provide a library that helps simplify
the manipulation of quotient types. We also leverage this new addition to the
language to introduce new built-in types, such as rational numbers,
propositional truncation, etc. Finally, this work also explores the development
of proofs in Typer, to our knowledge this is the first attempt to write a
substantial amount of proofs using the language since the language is primarily
intended to be a general-purpose programming language. We describe our
experience and the challenges faced in the process. Additionally, we introduce
several constructs to streamline proof development in Typer.

%%------------------------------------------------- %
%%        page v --- Table de matieres              %
%%------------------------------------------------- %

%% SM: IIRC to write your mémoire in English, you have to fill a form
%%   to "ask for permission".  It's a formality but don't forget to do it.

 % Pour un mémoire en anglais, changer pour
 % \anglais. Noter qu'il faut une permission
 % pour écrire son mémoire en anglais.
\anglais
%% \francais
 % \cleardoublepage termine la page actuel et force TeX
 % a poussé les éléments flottant (fig., tables, etc.) sur
 % la page (normalement TeX les garde en suspend jusqu'à ce
 % qu'il trouve un endroit approprié). Avec l'option <twoside>,
 % la commande s'assure que la prochaine page de texte est sur
 % le recto, pour l'impression. On l'utilise ici
 % pour que TeX sache que la table des matières etc. soit
 % sur la page qui suit.

\setcounter{tocdepth}{1} %% only part,chapters,sections in TOC
%% Only chapters in the appendix appear in the TOC
\appto\appendix{\addtocontents{toc}{\protect\setcounter{tocdepth}{0}}}

%% TABLE DES MATIÈRES
\cleardoublepage
\pdfbookmark[chapter]{\contentsname}{toc}  % Crée un bouton sur
                                           % la bar de navigation
\tableofcontents
 % LISTE DES TABLES
\cleardoublepage
\phantomsection  % Crée une section invisible (utile pour les hyperliens)
\listoftables

%%  % LISTE DES FIGURES
%% \cleardoublepage
%% \phantomsection
%% \listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LISTE DES SIGLES ET ABRÉVIATION %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Il est obligatoire, selon les directives de la FESP,
%% pour une thèse ou un mémoire d'avoir une liste des sigles et
%% des abréviations.  Si vous considérez que de telles listes ne seraient pas
%% pertinentes (si, par exemple, vous n'utilisez aucun sigle ou abré.), son
%% inclusion ou omission est laissé à votre discrétion.  En cas de doute,
%% parlez-en à votre directeur de recherche, le coadministrateur ou au/à la
%% bibliothécaire.
%%
%% Le gabarit inclut un exemple d'une liste « fait à la main ».  Il existe des outils
%% plus sophistiqués si vous devez inclure une multitude de sigles et abréviations.
%% Par exemple, le package <glossaries> peut faire des index élaborés.  Comme
%% son utilisation est technique, il n'y a pas d'exemple directement dans ce gabarit.
%% On invite les gens qui aurait à l'utiliser à lire la documentation officielle,
%% soit en allant sur https://www.ctan.org/, soit en tapant dans un terminal :
%%
%% texdoc glossaries
%%

\chapter*{Liste des sigles et des abréviations}
 % Option de colonnes: definir \colun ou \coldeux
%%% Exemple
%%% \def\colun{\bf} % Première colonne en gras
%%% Pour numéroté les entrées, on peut faire
%%% \newcount\abbrlist
%%% \abbrlist=0
%%% \def\plusun{\global\advance\abbrlist by 1\relax}
%%% \def\colun{\plusun\the\abbrlist. }
%%\def\coldeux{\relax}

%% TODO: Find all the other abbreviations and add them here

\begin{twocolumnlist}{.2\textwidth}{.7\textwidth}
  ETT & Extensional Type Theory\\
  HoTT & Homotopy Type Theory\\
  UIP & Uniqueness of Identity Proofs\\
\end{twocolumnlist}
%% L'environnement <threecolumnlist> existe aussi pour trois colonnes.

%%------------------------------------------------- %
%%              pages vi                            %
%%------------------------------------------------- %

\chapter*{Remerciements}

...remerciements...

 %
 % Fin des pages liminaires.  À partir d'ici, les
 % premières pages des chapitres ne doivent pas
 % être numérotées
 %

\NoChapterPageNumber
\cleardoublepage
\pagenumbering{arabic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                  %
%%   TEXTE DU MÉMOIRE :  introduction page 1,...    %
%%                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

The \emph{propositions as types} paradigm states that proofs are analogous to
programs. Writing programs in the form of code is equivalent to writing
mathematical proofs. For instance, a function of the type \fn{A $\rightarrow$ B}
is analogous to an implication \fn{A $\supset$ B}. If we think of the types
\fn{A} and \fn{B} as propositions, then such a function transforms all proofs of
\fn{A} to proofs of \fn{B}\footnote{We only consider total functions.}. Such a
function corresponds directly to our intuition of \emph{A implies B}, its
existence is thus a proof of \fn{A $\supset$ B}. A conjunction \fn{A $\wedge$ B}
is represented by a pair \fn{A $\times$ B}. To prove that \fn{A} and
\fn{B} are both true, we need a proof of \fn{A} and \fn{B} respectively, which
is precisely what we need a construct the pair \fn{A $\times$ B}. In the same
vein, a disjunction \fn{A $\vee$ B} is interpreted as a sum type \fn{A + B}. A
sum type has two constructors, one of them requires a proof of \fn{A} while the
other requires a proof of \fn{B}, this corresponds to our interpretation of
\fn{A $\vee$ B} that either \fn{A} or \fn{B} is true.

However, in order to do anything meaningful, we would need a way to express the
notion of equality, i.e.\ a crucial ingredient in expressing mathematical
truths. Since equalities are mathematical propositions, we require a type that
plays the role of equality in mathematical proofs. For instance, we might want
to state the theorem that the addition of natural numbers is commutative, i.e.
$\forall xy. \ x + y \equiv y + x$. To this end, our system requires an equality
type\footnote{In the literature, the terms `equality type', `identity type', and
`path' are used interchangeably. For our purposes, we shall employ the term
`equality type', though occasionally we shall use the term `path' to draw an
analogy with HoTT.} that allows us to make statements such as the above. Such a
type provides us with a proposition that can be manipulated like any other. This
implies that we can manipulate it with other operations such as logical
negation, conjunction, disjunction, etc. What we have just described is what is
commonly known as \emph{propositional equality}.

%% TODO: I could add one more example if something good comes to mind.
%% SM: A bit of motivation for why we care about proofs in programs
%% would be welcome.

Not only can we write mathematical proofs, but we may also prove properties of
our programs. In general, it is desirable for proofs not to be executed during
runtime, i.e.\ we only want them to be verified at compile time, or more
precisely, during type-checking. This allows us to prove that our programs have
the right behaviour, and this is achieved without incurring an additional runtime
cost. This is mainly achieved through a certain feature of Typer that allows
certain terms to be marked as erasable, a point that we shall come back to
later. Consider a function that accesses the i$^{th}$ element of an array with the
below type:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
arrayGet : (a : Array A) @$\rightarrow$@ (i : Nat) @$\rightarrow$@ i < length a @$\rightarrow$@ A
\end{minted}

The above is a type declaration that says that the variable $\fn{arrayGet}$ has
what is on the right of the colon as its type. $\rightarrow$ is a constructor of
function types. For instance, $\fn{A $\rightarrow$ B}$ is a type of a function
that accepts an argument of the type $\fn{A}$ and returns something of type
$\fn{B}$. $\fn{arrayGet}$ may thus be seen as a function of three parameters.
The first parameter is an array $\fn{a}$ of type $\fn{Array A}$, i.e.\ an array
that contains elements of type $\fn{A}$. The reason why it is given a specific
name $\fn{a}$ is that subsequent parameters may depend on it as Typer is a
dependently typed language. The second parameter $\fn{i}$ is a natural number
--- the index of the element we wish to retrieve from the array. The last
parameter is a proof that the index $\id{i}$ is indeed within the bounds of the
array. This is our first example of dependent types, whose defining
characteristic is that types may depend on terms. The type $\fn{i < length a}$
depends on the terms $\fn{i}$ and $\fn{length a}$. When the function is called
with all three arguments, it then returns something of type $\fn{A}$ --- the
element of the array that we are trying to retrieve. This gives us a guarantee
that array accesses will never lead to a runtime error. Additionally, this could
also allow us to skip runtime bounds-checking as the index is necessarily valid
as long as the program is well-typed.

In general, proofs improve the reliability of programs by allowing more errors
to be detected at compile-time by making use of the type system to impose
constraints on programs. A notable example of the usage of proofs in real-world
programs is the CompCert project that worked on the formal verification of a C
compiler\cite{Leroy-Compcert-CACM}. Equality proofs may also be used as the
backbone of more sophisticated features that improve the expressivity of a
language. For instance, they are used extensively in the internal language of
the Glasgow Haskell Compiler (GHC) as they form the backbone of features such as
generalised algebraic data types, functional dependencies, and associated
types\cite{sulzmann2007systemfeq}.

\section{Equality}

%% SM: This gets technical very quickly.  I think some of it may not
%% belong in the intro.  E.g. I think we can skip the definition of Vector
%% and just state that we somehow have a type `Vector α n`.  The definition
%% of Vector can/will probably appear later, but not in the intro.

%% TODO: ^ Revisit this soon

For two terms $x$ and $y$ of the same type $A$, we would like to be able to
state the proposition that the two terms are equal. For now, we merely consider
equality between terms of the same type. This gives us a type former that takes
a type as input, along with two terms of that type. In Typer, equality between
terms is represented by the $\kw{Eq}$ type former.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq : (A : Type) @$\Rrightarrow$@ (x y : A) @$\rightarrow$@ Type
\end{minted}

Just like $\id{arrayGet}$, $\id{Eq}$ is a function. However, instead of
returning values, it returns types. Since this type of function constructs
types, it is also known as a type former. $\id{Eq}$ takes as arguments a type
$\id{A}$ and two terms $\id{x}$ and $\id{y}$ of type $\id{A}$. The usage of
$\Rrightarrow$ indicates that the parameter $\id{A}$ is implicit and erasable,
this is explained in greater detail in \autoref{sec:eq-justification}. Recall
that types may be seen as propositions, the type $\fn{Eq x y}$\footnote{For
aesthetic purposes, we shall use the operator $\equiv$ to represent the
$\kw{Eq}$ type throughout the rest of this work, i.e.\ we write $\fn{Eq x y}$ as
$\fn{x $\equiv$ y}$.} is thus a proposition that $\fn{x}$ and $\fn{y}$ are
equal, and its terms are proofs of this proposition.

We could then construct the type that stipulates that the addition of natural
numbers is commutative by using the $\kw{Eq}$ type former.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Nat+_comm : (m : Nat) @$\rightarrow$@ (n : Nat) @$\rightarrow$@ m + n @$\equiv$@ n + m
\end{minted}

$\fn{Nat+\_comm}$ takes 2 natural numbers $\fn{m}$ and $\fn{n}$ as arguments and
returns a proof that \fn{m + n $\equiv$ n + m}. \fn{m + n $\equiv$ n + m} is
merely a type and can be seen as a statement of the proposition that \fn{m + n}
and \fn{n + m} are equal. To prove that the proposition is 
true, we would need to construct a term of this type. Such a term may be seen as
a proof object that witnesses the validity of the proposition. Interested
readers may find the complete proof of the commutativity of the addition of natural
numbers in \autoref{app:other-proofs}.

To see how such a proof may be utilised, suppose we have a type of
length-indexed vectors:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Vector : (A : Type) @$\rightarrow$@ Nat @$\rightarrow$@ Type
\end{minted}

This type is parametrised by \fn{A}, the type of the elements of the vector, as
well as a natural number that represents its length, this is once again an
instance of a dependent type as the type refers to a term of type \fn{Nat}. The
fact that the vector type is indexed by its length allows us to conduct more
static checks that verify that our program is well-behaved since functions are
able to impose constraints based on the length of vectors. However, this is not
without its disadvantages as programmers are now burdened with the
responsibility of proving at various points during the program that their
vectors have the `right length'. To humans, the fact that \fn{Vector A (m + n)}
and \fn{Vector A (n + m)} are the same is something trivial and is often taken
for granted. In general, the type checker of a dependently typed language would
not immediately consider the above types equal without further evidence. Hence,
one would not be able to pass a vector of the first type to a function that
expects a vector of the latter type. Suppose we have a function that zips
vectors, it could reasonably expect both input vectors to have the \emph{same}
length. Hence, the zipping of a \fn{Vector A (m + n)} and a \fn{Vector A (n +
  m)} would not type-check. Below is a typical definition of the addition
operation on natural numbers:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
_+_ : Nat @$\rightarrow$@ Nat @$\rightarrow$@ Nat
_+_ x y = case x
  | zero @$\Rightarrow$@ y
  | succ x' @$\Rightarrow$@ succ (x' + y)
\end{minted}

The function is defined by case analysis on its first argument, it is thus not
immediate that for arbitrary natural numbers \fn{m} and \fn{n}, \fn{m + n} and
\fn{n + m} would evaluate to the same thing. Hence, if a programmer wishes to
use a term of type \fn{Vector A (n + m)} in place of one of type \fn{Vector A
  (m + n)}, he would be required to state and prove the propositional equality
\fn{Vector A (m + n) $\equiv$ Vector A (n + m)}. Once we have such a proof, we
may then use it to cast vectors between those two types. This is achieved by
defining a function like the one below:

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
Vlength_comm+ : (m n : Nat) @$\Rrightarrow$@ Vector ?A (m + n) @$\rightarrow$@ Vector ?A (n + m)
Vlength_comm+ = lambda A m n @$\Rrightarrow$@ Eq_cast (p := Nat+_comm m n) (f := Vector A)
\end{minted}

\fn{Vlength\_comm+} is a function that converts a vector of type \fn{Vector A (m
  + n)} to one of type \fn{Vector A (n + m)}. By making use of a proof that
\fn{m + n $\equiv$ n + m}, we can perform type casting on a vector of
type \fn{Vector A (m + n)} to produce a vector of the desired type. If we had a data
type of matrices indexed by their dimensions, the cast operation might also be
necessary to ensure the appropriate alignment of dimensions when working with a
function that calculates matrix products. The equality type satisfies Leibniz's
principle of the indiscernibility of identicals, i.e.\ two identical things may
be substituted for one another. \fn{Eq\_cast} is thus of the fact that if two
terms are equal, then if a predicate is true of the first term, it is
necessarily also true for the other.

Now that we have seen how equality proofs may be used in programs, the next
question that ought to be answered is how are such terms introduced. The one and
only constructor of the $\kw{Eq}$ type is the following:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq_refl : (x : ?A) @$\Rrightarrow$@ x @$\equiv$@ x;
\end{minted}

Given a term $x$ of an arbitrary type $A$, we can trivially construct the proof
that $x$ is equal to itself. This is known as the reflexive proof of equality.

What we have just seen is commonly known as homogeneous equality as only terms
of the same type may be equated under this form of equality. Occasionally, it is
also useful to be able to relate two terms of types that are not definitionally
equal. Suppose that we had the terms \fn{u:Vector A (m + n)} and \fn{v:Vector A
  (n + m)} and that we would like to construct a proposition of their equality.
We would not be able to do it with the \fn{Eq} constructor as \id{u} and \id{v}
are not of the \emph{same} type, though we know that the types may be proven to
be equal. To state equalities between terms of different types, McBride
introduced the notion of heterogeneous equality\cite{mcbride2000dependently},
with which we may state our desired equality as \fn{Heq u v}. However, for two
things to truly be equal, they need to be one and the same, their types
included. This is witnessed by the constructor of \fn{Heq} which has the
following type.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Heq_refl : (x : ?A) @$\Rrightarrow$@ Heq x x;
\end{minted}

In subsequent sections, we discuss the introduction of heterogeneous equality to
Typer and its role in the elimination of quotients.

%% SM: I recommend you test-run this paragraph(subsection) by passing it to
%% some programmer friend of yours (someone not familiar with topology),
%% to see how much they understand.

%% NOTE: Someone told me that the unit interval business is not very intuitive.
%% Maybe I should shorten this section and postpone explanations to subsequent
%% sections instead.
\subsection*{Cubical Equality}

%% SM: The formulation "function out of" is not very common, so I wouldn't
%% be surprised if it catches some readers off-guard.
Recent advances in type theory inspired by topology propose a different approach
to represent equality proofs by modeling them as functions out of a unit
interval to some type A. In this alternative formulation of equality proofs,
equality is viewed as a continuous path along the unit interval that connects
two equal terms. The return value of such functions is not allowed to directly
depend on the value of the interval argument. For instance, the function may not
do a case analysis on the interval and return a different term of type A
depending on which endpoint of the interval is encountered. This essentially
implies that such a function would indeed be constant on the unit interval and
aptly respects the requirements of an equality proof. An equality type based on
the interval also allows us to derive many proofs regarding the equality type in
an alternative manner that is much cleaner and more elegant. It also allows us
to derive new theorems regarding the equality type that are desirable, such as
functional extensionality. This flavour of equality was first conceived in
cubical type theories to provide a computational interpretation of the
univalence axiom\cite{bezem2014model}. This allows the encoding of equivalences
as equalities. This is much like what is done in informal mathematics where
objects with equivalent structures are just taken to be the ``the same''.

Encoding equivalences as equalities is the bread and butter of univalence. It is
thus crucial that equality proofs are not irrelevant in a HoTT setting, as their
equalities could be constructed based on equivalences and thus have a
computational role. As a general-purpose programming language, Typer has no
ambitions of supporting univalence. Thus, it is desirable for equality proofs in
Typer to remain irrelevant so that they may be erased before runtime. This is
essential so that operations involving the equality type may be treated as
no-ops during runtime. If all equality proofs are merely reflexivity proofs in
disguise (?), then type casts using the \fn{Eq\_cast} primitive simply behave
like the identity function at runtime as we would merely need to cast a term to
its own type. This is in stark contrast to equalities that are equivalences, a
cast at runtime would involve applying the underlying function of the
equivalence, i.e.\ casting involves computation. In our work, we carefully adapt
the cubical equality type to Typer to reap the benefits of having a more
powerful equality type, all while preserving our equality type's compatibility
with proof irrelevance.

\section{Quotients}

In keeping with the theme of equality, we shall discuss the implementation of
quotient types in Typer. Quotient types allow us to redefine the equality of a
type, usually based on an equivalence relation on the type. This is
inspired by quotients in set theory, where if we are given a set A and an
equivalence relation $\sim$ on A, then we can construct the quotient set of A by
$\sim$, which we denote as $A / \sim$. Equivalent elements in A are considered
equal in $A / \sim$. Conversely, the subsets of elements that are considered
equal in $A / \sim$ are precisely the subsets whose elements are all equivalent
under the equivalence relation. We can say that for some $a \in A$, the subset
of $A$ such that all elements are equivalent to $a$ is $\{a' \in A \ | \ a' \sim
a \}$. Indeed, this subset is what one would call the equivalence class of $a$,
this is usually denoted as $[a]$. When we take the quotient of a set, we are
essentially partitioning the set into equivalence classes, implying that we can
regard a quotient set as simply the set of equivalence classes induced by the
equivalence relation. For example, consider the integers modulo \id{5} where the
underlying relation is congruence modulo \id{5}. Here, 0, 1, 2, 3, and 4 are the
canonical representatives of their respective equivalence classes, or more
specifically, congruence classes.

\begin{equation}
\mathbb{Z} / 5\mathbb{Z} = \{ [0], [1], [2], [3], [4] \}
\end{equation}

%% SM: Another way to look at it is to say that, as programmers we
%% often end up defining types that allow several different representations
%% of the same thing (like syntax with names instead of deBruijn indices,
%% or binary trees, where any rotation preserves the "meaning").  Usually
%% this is not expressed formally in the code (or its type), but often
%% we want to hide those details, typically using abstraction barriers;
%% and as programmers we need to convince ourselves that the exposed API
%% doesn't end up accidentally revealing internal details.
%% Quotient types let you define explicitly what information is "exposed"
%% vs what information is "internal details" and have the type checker
%% verify that your abstraction doesn't leak.

%% NOTE: Let's see how I can adapt the above, I like some of the ideas but not
%% all of them. I like the BT example, but the one with DB indices is less
%% convincing. The former has a direct link to quotients whereas the latter is
%% an analogy. Another good example is maybe the alpha equivalence of functions.

%% Often, types that we define permit multiple internal representations that are
%% equivalent. Such equivalences may be seen as `redundancies' in the base type
%% as far as our purposes are concerned. Quotient types are a way of taking
%% advantage of the type checker to ensure that these redundancies are
%% appropriately handled internally. I think that instead of saying that we can
%% control what is ''exposed`, I would rather say that what we end up exposing
%% is necessarily `lawful' wrt to the quotient.

From the perspective of programming, data types that we define are often based
on other existing data types that are used as the \emph{internal representation}
of the new data type. In some cases, different `configurations' of the internal
data type may be equivalent as far as the new data type is concerned. For
instance, different rotations of a binary tree may be treated equivalently. If
we wish to represent unordered sets using lists, then we would like to treat
different permutations of the same list equally. These nuances are not typically
explicitly expressible in the implementation of the data types nor may they be
encoded at the type level. They are instead treated as \emph{implementation
details} which one hopes to encapsulate by using abstraction barriers. Quotient
types enable elements of the same equivalence class to be treated
\textbf{equally}. Thus, they are a way of taking advantage of the type checker
to ensure that these details are appropriately handled internally. This is the
case because only programs that treat these equivalences consistently may be
well-typed. Quotient types also serve as a form of documentation that explains
the inner workings of a data type.

For a more concrete example, consider the set of rational numbers defined as
such:

\begin{equation}
\mathbb{Q} = \{(x,y) : x \in \mathbb{Z}, y \in \mathbb{Z}, y \ne 0\}
\end{equation}

We represent a fraction as a pair of integers such that the first integer is the
numerator and the second non-zero integer is the denominator. We note that each
rational number should then be considered equal to an infinite number of other
rationals. For example, $\frac{0}{1}$ should be equal to $\frac{0}{-2}$,
$\frac{0}{-1}$, $\frac{0}{2}$, $\frac{0}{3}$ etc. However, the naive encoding of
the rationals as pairs of integers does nothing to ensure that equal rationals
are indeed treated equally. This problem is remedied by quotienting pairs of
integers by an appropriate equivalence relation.

%% SM: I think the Miranda article also fits here.
%% That article might also be a good way to motivate your work: quotients
%% were introduced early on in FP, but they didn't catch on, and you can
%% argue that it's maybe because they couldn't manipulate proofs, so now
%% the time is ripe for the second coming.

There also exists a class of quotients that can be defined without the addition
of a new type former, i.e.\ quotients that are characterised by a normalisation
function\cite{li2015quotient,courtieu-normalizedtypes}. For these quotients, it
is possible to elect a canonical representative for each equivalence class. This
idea is reminiscent of the \emph{laws} in the Miranda programming
language\cite{thompson1986laws}. Its algebraic data types may be defined with
rewrite rules that ensure that its terms are always in normal form. These rules
are in fact just smart constructors in disguise, we are not able to reason about
and write proofs about laws. However, the innovation of Miranda is not its smart
constructors, but rather its introduction of the idea of stating the equivalence
between terms of the same type. All this to say that ideas related to quotients
have been introduced to functional programming in its early years, however, they
did not gain mainstream adoption. Dependently typed languages were also still
nascent at that time, making it more challenging for quotient types and their
entailed proof obligations to be aptly integrated into functional languages.
With the gradual maturing of dependently-typed languages, we believe that it is
an opportune moment to bring quotients into the picture again. In the rest of
this thesis, we discuss our experience of introducing quotient types to Typer.
We first describe the typing and reduction rules of the introduced quotient
type, and then we discuss the library that was implemented to facilitate their
usage in Typer. Finally, we illustrate how the quotient type may be used by
providing examples in the form of code along with commentary.

\section{Contributions}

We make several contributions:

\begin{itemize}
  \item{First, we introduce a notion of heterogeneous equality based on the
    Interval type by drawing inspiration from cubical type theory
    (\hyperref[ch:cubical-equality]{Chapter~\ref*{ch:cubical-equality}}).
    Heterogeneous equality makes it possible to identify terms of different
    types\footnote{To identify A and B is to claim that they are equal.}. }

  \item{Next, we defined normal homogeneous equality as a special case of
    heterogeneous equality. We then showed that by an interval-based equality
    type lends itself better to proof of equality related properties
    (\hyperref[sec:eq-examples]{Section~\ref*{sec:eq-examples}}).}

  \item{We then introduced quotient types along with their typing and reduction
    rules (\autoref{ch:quot}). Its elimination principle takes advantage of
    heterogeneous equality by using it to express
    pathovers\cite{licata2015cubical}. We also convince ourselves that our
    quotients behave appropriately by proving their effectiveness
    (\autoref{ch:quotient-effectiveness}) and that they fulfil the universal
    property of quotients (\autoref{sec:coequaliser}). }

  \item{To facilitate the use of quotients, we developed a library of
    convenience functions, macros, and also theorems regarding quotient types
    (\autoref{ch:quot-examples}). This work explores the usability and
    user-friendliness of quotient types in programming tasks through the
    constructions of examples of possible use cases of quotients. We also
    investigate the runtime overhead of the utilisation of quotient types
    (\autoref{sec:quot-benchmark}).}

  \item{We also implemented a proof of Hedberg's
    theorem\cite{hedberg1998coherence} in Typer
    (\hyperref[subsec:hedberg]{Subsection~\ref*{subsec:hedberg}}). The theorem
    states that if a type has decidable equalities, then its equalities are
    necessarily trivial. Using such a type as the elimination motive of a
    quotient type entails fewer proof obligations. }

  \item{As the first work to develop a substantial number of proofs in Typer,
    our experiennce lead us to introduce several constructs to facilitate the
    development of proofs in Typer in the form of macros and axioms. }
\end{itemize}

\section{Notes and TODOs}
- We have a proof of Hedberg's theorem to facilitate eliminations to `Sets'.
After explaining why this is necessary, we can motivate the addition of the set
truncation constructor for Quotients. If we can prove that $\mathbb{Z}$ is a set
when defined inductively (with the aforementioned theorem), then it would be odd
if the same cannot be done if $\mathbb{Z}$ was defined as a quotient of
$\mathbb{N} \times \mathbb{N}$. Indeed, this entails bigger consequences (as
%% SM: Use a proper `\cite`
mentioned in https://staff.math.su.se/anders.mortberg/papers/cubicalagda2.pdf
section 2.4.1). (TODO:\ refer to my notes for a proof that Unit $\ne$ Unit/R
without the truncation).

%%------------------------------------------------- %
%%                Chapters                          %
%%------------------------------------------------- %

%% SM: I think we need a background / state-of-the-art chapter here, first,
%% You could move the "related works" chapter to here as a start, but it
%% should have a more "introductory" feel to it.
%% That chapter would kinda repeat the intro to some extent, but going in
%% more details and talking more concretely about what existing systems do.
%% You could talk in general terms about HoTT and how it introduced a host of
%% new ideas, including HITs and a refined notion of equality, then
%% show how this has been turned into practice in existing systems
%% (clarifying along the way the difference between quotients and HITs).
%% In that chapter, I'd expect you'd mention also setoid rewriting, as well
%% as various attempts to add quotients to Coq, Miranda, ...
%% This way, when you get to talk about your work, in the next chapters
%% you can better situate it as a kind of compromise between HoTT concepts
%% and more traditional notions.
%% In this new chapter, you still don't want to be technical, you want
%% most readers to still enjoy the ride and get the illusion that they
%% understand.
%% You could also use this chapter to give a quick intro to the relevant
%% part of Typer.

\chapter{Cubical Equality}\label{ch:cubical-equality}
%% SM: You need some introductory text here (between \chapter and \section).
%% Or maybe just move the \section header after its first paragraph.
\section{Interval type}

%% SM: Give some indication of the context in which such a definition
%% might be considered "typical".
First, we provide the typical definition of the interval type as can be found in
%% SM: When citing articles, we typically cite just the article
%% but when citing a subject treated in some part of a book, you don't
%% want to just cite the book, you want to additionally mention which
%% chapter you're referring to.
various sources such as the HoTT book\cite{HoTTbook}, subsequently we present
our alternative formulation of the interval type and show that it is equivalent
to the traditional definition. We carry out the below presentation in a system
that already has a notion of propositional equality unrelated to the interval
type, which we denote with $\equiv$ for aesthetic purposes.
%% SM: Clarify what's up with this \equiv.  E.g. say that *for now* we presume we
%% have such a thing, just while we try to help the reader build an intuition
%% about what we're presenting, but that later on we're going to actually
%% define it.  Or maybe, actually give a definition of \equiv like HoTT-Book does.
%% IIUC in this section you want to stay close to "an standard
%% presentation", so a good choice is to literally copy the notation
%% and the definitions from a known references (like HoTT-Book) and say
%% so explicitly.

%% SM: Put those 4 axioms together so they use the space better, e.g. with
%% a `mathpar` environment.
\begin{prooftree*}
   \infer0{\oftype{\ctx}{\bI}{\kw{Type}}}
\end{prooftree*}

\begin{prooftree*}
   \infer0{\oftype{\ctx}{i_{0}}{\bI}}
\end{prooftree*}

\begin{prooftree*}
   \infer0{\oftype{\ctx}{i_{1}}{\bI}}
\end{prooftree*}

\begin{prooftree*}
   \infer0{\oftype{\ctx}{seg}{\eqtype{i_0}{i_1}}}
\end{prooftree*}

We postulate the existence of the interval type $\bI$, along with its endpoints
\id{$i_0$} and \id{$i_1$}. The intuition is that elements of $\bI$ correspond to
%% SM: Your readers might still not intuitively equate "\equiv" with "continuous
%% path", so state it both ways to remind them that we're considering both
%% notions as interchangeable.
points in the real unit interval $[0, 1]$. We also have \id{seg} which is a
witness of a continuous path between \id{$i_0$} and \id{$i_1$}.

%% SM: You use "Elimination" here and "recursion" later.
%% TODO: Think about this, maybe what I should do is just introduce the entire
%% thing as the `elimination' principle and not the `recursion' principle.
%% SM: Sounds good to me (there's no actual recursion involved anyway).
%% SM: Also, some readers may not be fully familiar with the terminology
%% of "elimination principle", so you can explicitly mention
%% "if/then/else" as the elimination principle for booleans.
Elimination of $\bI$ is similar to that of \id{Boolean}, the only difference is
%% SM: "a proof ... to prove" 🙁
that a proof must be provided to prove that $\eqtype{i_0}{i_1}$ is respected.
The recursion principle of $\bI$ can thus be stated as follows\footnote{This has
nothing to do with recursive function calls. When we say recursion principle, we
refer to the definition as is employed in an introduction to the \Coq{} proof
assistant\cite{chlipala2022certified}. This terminology has also been employed
in the HoTT book\cite{HoTTbook}.}:

%% SM: Again, how is ≡ defined?  You don't necessarily need to explain it
%% but at least point out the apparent circularity.
%% SM: Before showing this rule, you also want to present the
%% {rec_{\bI} (\_. A, P, i)} syntax
\begin{prooftree*}
   \hypo{\oftype{\ctx}{M}{A}}
   \hypo{\oftype{\ctx}{N}{A}}
   \hypo{\oftype{\ctx}{P}{\eqtype{M}{N}}}
   \infer3{\oftype{\ctx, \oftype{i}{\bI}}{rec_{\bI} (\_. A, P, i)}{A}}
\end{prooftree*}

%% SM: Try and give some intuition for what I is like.
It has the below computation rules:

%% SM: These don't look computational at all, since you reduce to "M"
%% something that doesn't include any M anywhere.
\begin{align*}
  & rec_{\bI}(\_ . A, P, \ileft) = M \\
  & rec_{\bI}(\_ . A, P, \iright) = N \\
  & \kw{cong}_{rec_{\bI}(\_ . \bI, P)}(\id{seg}) = P
\end{align*}

%% SM: State what is "the congruence property of equality".
\kw{cong} refers to the congruence property of equality and is explained in more
detail in \autoref{subsec:congruence-eq}. We can expect the first two equations
to hold definitionally. Definitional equality of two terms is determined by
expanding out definitions. So if we say that $rec_{\bI}(\_ . A, P, \ileft)$ is
definitionally equal to $M$, we are saying that the former reduces to the latter
when we check for equality. If we imagine that the first two computation rules
were defined via pattern-matching, it would make sense for these equations to
%% SM: Since you haven't actually explained what each part of
%% \kw{cong}_{rec_{\bI}(\_ . \bI, P)}(\id{seg}) stands for (or even "is"),
%% your readers have probably no idea whether it's curious or not.
%% This said, at least that reduction does include the resulting "P"
%% somewhere on the left hand side, so it does look "computational".
hold definitionally. The third equation is a more curious case, it suggests that
by the congruence of equality, the application of the $\kw{Interval}$ recursor
with the equality proof $\id{P}$ to $\id{seg}$ should yield an equality proof
between $\id{M}$ and $\id{N}$. More specifically, such an equality proof should
be equal to $\id{P}$ itself. From a computational point of view, equalities
between equality proofs are only an important consideration in a proof-relevant
setting, e.g.\ in the context of HoTT. In the world of Typer where we demand
that equality proofs be erasable and play no role during computation, such
equalities are less meaningful. However, they are not completely irrelevant as
we occasionally need to construct such proofs for coherence purposes. In most
cases, the third equation only holds propositionally, as is the case when it is
defined as a user-defined datatype in other type systems such as \Agda{}.

\section{Motivation}
%% SM: Maybe give an intuition why this is true, maybe comparing `I` to
%% a boolean type where you are not able to distinguish true from false?
We show that a function with an interval argument returning some type \id{A},
i.e.\ a function with type \fn{$\bI \rightarrow A$} is equivalent to an equality
proof between two terms of type \id{A}. To build an intuition as to why this
might be true, consider a \id{Boolean} type where \id{true} and \id{false} are
indistinguishable. Then a function with this \id{Boolean} type as an argument is
necessarily constant on its argument. Suppose that we have such a function named
\id{h}, we thus have a witness of the equality of \fn{h $\ileft$} and \fn{h
  $\iright$}.

In order to state the aforementioned theorem, we first introduce dependent
pairs. We use the usual syntax to denote the type of dependent pairs,
i.e.\ $\Sigma_{\oftype{x}{A}}. B$. Here, the first projection of type \id{A} and
is named \id{x}; the type of the second projection,\id{B} may depend on the term
\id{x}. Terms of dependent pairs have the following form $\braket{a, b}$. Now,
we formally state the theorem that we are interested in

\begin{theo}
  %% SM: "may be"?
The following type may be inhabited:

%% SM: There's too much space around this math element.
\begin{align*}
  & \bI \rightarrow A \ \simeq \ \Sigma_{\oftype{x}{A}} . \Sigma_{\oftype{y}{A}} . \eqtype{x}{y}
\end{align*}

\end{theo}

\begin{proof}
We define functions \id{f} and \id{g} as inhabitants of the forward and backward
directions of the equivalence respectively. We prove this equivalence by proving
that \fn{g} is a quasi-inverse of \fn{f} as described in chapter 2 of the HoTT
%% SM: Use \cite[Chap. 2]{...} instead of "in chapter 2 of \cite{...}".
book\cite{HoTTbook}. To this end, we define \id{f} and \id{g} as such:

%% TODO: I glossed over this detail, but the $rec_{\bI}$ actually carries out a
%% depelim which I haven't introduced yet.

%% SM: I think a "paper proof" would be a better choice than a formal proof
%% because you use here many constructs that you haven't presented.
%% IOW, start with g(f(h)), then show how it reduces to (something equivalent
%% to) h, then same thing for f(g(e)).
\begin{align*}
  & f : (\bI \rightarrow A) \rightarrow \Sigma_{\oftype{x}{A}} . \Sigma_{\oftype{y}{A}} . \eqtype{x}{y} \\
  & f(h) := \braket{\id{h}(\ileft), \braket{\id{h}(\iright), \kw{cong}_{\id{h}}(\id{seg})}} \\ \\
  & g : \Sigma_{\oftype{x}{A}} . \Sigma_{\oftype{y}{A}} . (\eqtype{x}{y}) \rightarrow  (\bI \rightarrow A) \\
  & g \braket{x, \braket{y, p}} := \lambda \id{i} . \ rec_{\bI}(\_ . \id{A}, \id{p}, \id{i})
\end{align*}
%% SM: You need to "read aloud" to explain what this does.
%% Alternatively, you may relegate this proof to a later chapter.
%% TODO: Figure this out

Now, we need to prove that \id{g} is both the left and right inverse of \id{f}.

\begin{align*}
  & \id{$\alpha$-helper} : (\oftype{h}{\bI \rightarrow A}) \rightarrow (\oftype{i}{\bI}) \rightarrow \eqtype{(g (f \ h)) \ i}{h \ i} \\
  & \id{$\alpha$-helper} (h , i) = rec_{\bI}(i . \ \eqtype{(g (f \ h)) \ i}{h \ i}, \ \kw{cong}_{\lambda i . \refl{h(i)}}(\id{seg}), \ i) \\
  & \alpha : (\oftype{h}{\bI \rightarrow A}) \rightarrow \eqtype{g(f(h))}{h} \\
  & \alpha(h) =  \kw{funExt} (\id{$\alpha$-helper} (h)) \\ \\
  & \beta :  (\oftype{e}{\Sigma_{\oftype{x}{A}} . \Sigma_{\oftype{y}{A}} . \eqtype{x}{y}}) \rightarrow f(g(e)) = e \\
  & \beta(e) =  \refl{\Sigma_{\oftype{x}{A}} . \Sigma_{\oftype{y}{A}} . \eqtype{x}{y}}{e}
\end{align*}

%% The proof of beta is done via refl by leveraging the eta-equivalence of the
%% sigma type
For the sake of simplifying the proof of $\beta$, we assume the $\eta$-rule for
dependent pairs. And with that, the proof is complete.

\end{proof}

\section{Justification}\label{sec:eq-justification}
We have established in the previous section that equality between two terms is
equivalent to a function out of the interval. We have also illustrated that the
output of such a function has to agree at both endpoints of the interval. This
is enforced by the elimination principle of the $\bI$ that ensures that \id{seg}
is respected. An alternate way of enforcing this is by using functions with
erasable arguments out of a $\mathbbm{2}$-type, i.e.\ a type with two distinct
constructors that take no arguments, such as the \id{Boolean} type. An argument
that is marked as erasable has no computational role during runtime. Within the
function body, such an argument may only be used in an \emph{erasable} manner,
for instance, it may be used in the computation of an expression that is passed
as an erasable argument to yet another function. In other words, we can first
define the \id{Interval} type as a normal algebraic data type. Next, we can
model the equality type as a function with an erasable argument out of the
\id{Interval} type.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
type I
  | @$i_0$@
  | @$i_1$@
\end{minted}

And then define a function with the following type:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
h : I @$\Rrightarrow$@ A
\end{minted}

In Typer, we use $\Rrightarrow$ to denote erasable arguments in function types.
It is vacuously true that $\eqtype{h(i_0)}{h(i_1)}$ since what is returned by
the function could not have been influenced by the argument that was passed to
it because the argument is erasable. With that, we can postulate that

\begin{align*}
  & \bI \Rrightarrow A \simeq \Sigma_{\oftype{x}{A}} . \Sigma_{\oftype{y}{A}} .
  \eqtype{x}{y}
\end{align*}

The above shall be the basis of our new definition of identity types.

\section{Manipulation of the Interval type}

We introduce a few operations on the interval type whose usefulness will become
clear after we introduce our version of the equality type that is based on the
interval type.

\subsection*{Negation}

The negation operator does what its name suggests, i.e.\ it simply negates
endpoints of the Interval type. Unsurprisingly, it has the following type:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
I_not : I @$\rightarrow$@ I
\end{minted}

The negation operator computes as follows:

%% SM: A common practice is to use \textsc to name rules.
\begin{mdframed}[nobreak=true]
  \begin{center}
    \begin{prooftree}
        \infer0[I-NOT$_1$]{\Funapp{\fn{I\_not}}{i_0} \rightsquigarrow{} i_1}
    \end{prooftree}
    \qquad
    \begin{prooftree}
        \infer0[I-NOT$_2$]{\Funapp{\fn{I\_not}}{i_1} \rightsquigarrow{} i_0}
    \end{prooftree}

    \hfill \break

    \begin{prooftree}
        \infer0[I-NOT-NOT]{\Funapp{\fn{I\_not}}{(\Funapp{\fn{I\_not}}{i})}
            \rightsquigarrow{} i}
    \end{prooftree}
  \end{center}
\end{mdframed}

I-NOT-NOT is a special rule that states that the composition of \fn{I\_not} with
itself is equal to the identity function. This is something that we could have
proven propositionally, however, we have set things up such that this holds
definitionally. This is not entirely necessary, though it makes proofs that do
indeed require this property a lot simpler and more elegant, allowing us to
fully benefit from having an interval-based equality type.

\subsubsection*{Meet}\label{subsubsec:interval-meet}

The meet operator returns the minimum of two terms of the Interval type. The
order of the Interval type is such that $i_0 \le i \le i_1, \forall i \in I$

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
I_meet : I @$\rightarrow$@ I @$\rightarrow$@ I
\end{minted}

It has the following reduction rules:

\begin{mdframed}[nobreak=true]
    \begin{center}
        \begin{prooftree}
            \infer0[I-MEET$_1$]{\Funapp{\fn{I\_meet}}{i_0}{i}
                \rightsquigarrow{} i_0}
        \end{prooftree}
        \qquad
        \begin{prooftree}
            \infer0[I-MEET$_2$]{\Funapp{\fn{I\_meet}}{i_1}{i}
                \rightsquigarrow{} i}
        \end{prooftree}

        \hfill \break

        \begin{prooftree}
            \infer0[I-MEET$_3$]{\Funapp{\fn{I\_meet}}{i}{i_0}
                \rightsquigarrow{} i_0}
        \end{prooftree}
        \qquad
        \begin{prooftree}
            \infer0[I-MEET$_4$]{\Funapp{\fn{I\_meet}}{i}{i_1}
                \rightsquigarrow{} i}
        \end{prooftree}

        \hfill \break

        \begin{prooftree}
            \infer0[I-MEET$_5$]{\Funapp{\fn{I\_meet}}{i}{i}
                \rightsquigarrow{} i}
        \end{prooftree}
    \end{center}
\end{mdframed}

I-MEET$_1$ is valid as $i_0$ is lesser or equal to anything else. In a similar
fashion, I-MEET$_2$ is justified as everything is lesser or equal to $i_1$.
Since the operator is commutative, I-MEET$_3$ and I-MEET$_4$ are complementary
to I-MEET$_1$ and I-MEET$_2$. The minimum of $\id{i}$ and $\id{i}$ is $\id{i}$
itself, justifying the I-MEET$_5$ rule. Note that since the Interval type does
not behave like a Boolean algebra, it is not the case that
%% SM: I think you mean that it does not hold definitionally, but it does
%% hold propositionally, right?
$\Funapp{\fn{I\_meet}}{i}{(\Funapp{\fn{I\_not}}{i})} \rightsquigarrow{} i_0$.

\subsection*{Join}
%% SM: AFAIK, with De Morgan (and not&meet) you can define any function
%% on intervals.  The only question is which equivalences hold definitionally.
TODO:\ So far I haven't found a need for this operator. Do some investigation to
see if this is a worthy addition


TODO:\ I'm leaning towards adding it anyway for completeness' sake

\section{Elimination of the Interval type}

%% SM: I think this needs some discussion about what kind of behavior
%% we want from an elimination rule.  As it currently stands, this
%% section present a funny rule I_transp with very little explanation about
%% why it was defined this way.  What's so good about it?
%% I can see the answers in your text, but someone who doesn't know what
%% problems might need to be solved here will completely miss them
%% and feel completely puzzled by this definition, just like you didn't
%% found Cubical Agda's transport puzzlingly complicated at first.

%% SM: Why the negation?

We present the one and only elimination rule of our \type{Interval} type. It is
largely inspired by the (generalised) transport operation used in Cubical
Agda\cite{vezzosi2021cubical}. It has the following typing rule:

%% SM: Shouldn't the `r` param to `transp` be erased as well?
%% How 'bout passing it last (so that `transp A a` is the equality proof?
\begin{prooftree*}
  \hypo{\oftype{\ctx}{\id{A}}{\id{I} \Rrightarrow \type{Type}}}
  \hypo{\oftype{\ctx}{\id{r}}{\type{Interval}}}
  \hypo{\oftype{\ctx}{\id{a}}{\Funapp{\id{A}}{(\earg{\id{i}_0})}}}
  \infer3{\oftype{\ctx}
                 {\Funapp{\id{I\_transp}}{\id{A}}{\id{r}}{\id{a}}}
                 {\Funapp{\id{A}}{(\earg{\Funapp{\id{I\_not}}{\id{r}}})}}}
\end{prooftree*}

We claim that this is a generalised version of the transport operation as the
argument \id{r} dictates when \id{I\_transp} should behave like the identity
function. When $\id{r} = \id{i}_1$, then the type of
$\Funapp{\id{I\_transp}}{\id{A}}{\id{r}}$ is $\Funapp{\id{A}}{(\earg{\id{i}_0})}
\rightarrow \Funapp{\id{A}}{(\earg{\id{i}_0})}$, i.e. it behaves like the
%% SM: Don't make such comments about details of Agda's rule
%% unless you actually first describe Agda's rule.
identity function. Since our version of $\id{I\_transp}$ is slightly different
from that of Cubical Agda, we do not need the additional side condition that
states that A needs to be a constant function when $\id{r} = \id{i}_1$ in order
for the above expression to typecheck. This is primarily because the ultimate
return type of the function is dependent on $\id{r}$ itself. When $\id{r} =
\id{i}_0$, then the type of $\Funapp{\id{I\_transp}}{\id{A}}{\id{r}}$ is
$\Funapp{\id{A}}{(\earg{\id{i}_0})} \rightarrow
\Funapp{\id{A}}{(\earg{\id{i}_1})}$, this gives us a function that transports an
expression of type $\Funapp{\id{A}}{(\earg{\id{i}_0})}$ to type
$\Funapp{\id{A}}{(\earg{\id{i}_1})}$. We shall make use of this property
subsequently to define the actual transport function. However, the other
property of the $\id{I\_transp}$ function may appear bizarre at first sight, but
in reality it ensures that $\Funapp{\id{I\_transp}}{\id{A}}{\id{r}}{\id{a}}$ is
equal to $\id{a}$\footnote{This equality would be heterogeneous as the two terms
may not have the same type}.

The computational behaviour of the function is as follows:

%% SM: Hmm... doesn't this break type-preservation since `a` has type `A i₀`
%% whereas `transp A i₀ a` has type `A i₁`?
\begin{prooftree*}
  \infer0{\Funapp{\id{I\_transp}}{\id{A}}{\ileft}{\id{a}} \rightsquigarrow \id{a}}
\end{prooftree*}

\begin{prooftree*}
  \infer0{\Funapp{\id{I\_transp}}{\id{A}}{\iright}{\id{a}} \rightsquigarrow \id{a}}
\end{prooftree*}

The function is implemented in Typer as a primitive with the following type
signature:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
I_transp : (A : I @$\Rrightarrow$@ Type) @$\Rrightarrow$@ (r : I) @$\Rrightarrow$@ A (_ := i0) @$\rightarrow$@ A (_ := I_not r)
\end{minted}

Its implementation is simple in that it simply returns the argument $\id{a}$
untouched when \id{r} is a canonical value of \id{Interval}.

\section{Identity type}\label{sec:identity}

\subsection{Heterogeneous equality}
With the above definition of $\bI$, we are now ready to introduce the notion of
heterogeneous equality. Such an equality type allows us to identify two terms
that are not necessarily of the same type. The heterogeneous equality type has
the following type signature\footnote{Although not mentioned explicitly,
functions involving the identity type are universe polymorphic in their
arguments and return type.} and is implemented axiomatically. Usually, when we
define an axiom in type theory, we simply claim that it is an inhabitant of some
type without saying anything about its behaviour. However, in our case, we also
supplement it with the appropriate reduction rules so it has the right
computational behaviour. In the absence of this, i.e.\ if we were to define the
computation rules for axioms in the form of propositional equalities, then the
usage of these axioms suffers greatly as programs and proofs tend to be clumsy
and inelegant.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Heq : (t : I @$\Rrightarrow$@ Type)
      @$\Rrightarrow$@ t (_ := i0) @$\rightarrow$@ t (_ := i1) @$\rightarrow$@ Type
\end{minted}

As we have previously proven, \fn{I $\Rrightarrow$ Type} is equivalent to an
equality between two types. Although we say that \fn{Heq} allows us to equate
two terms of different types, in reality, the two types have to be provably
equal. \id{Heq\_eq}, the constructor of \id{Heq} also leverages the property of
erasable functions out of the interval to accept an argument of that form as a
witness of the equality being constructed.

%% Heq_eq : (l : TypeLevel) ≡> (t : I ≡> Type_ l) ≡> (f : (i : I) ≡> t (_ := i))
%%           ≡> Heq (f (_ := i0)) (f (_ := i1))

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Heq_eq : (t : I @$\Rrightarrow$@ Type)
         @$\Rrightarrow$@ (f : (i : I) @$\Rrightarrow$@ t (_ := i))
         @$\Rrightarrow$@ Heq (f (_ := i0)) (f (_ := i1))
\end{minted}

The elimination of equality types merely does the opposite of the introduction
rule by returning a function out of the interval that represents the underlying
equality.

%% Heq_uneq : (l : TypeLevel) ≡> (t : I ≡> Type_ l)
%%                     ≡> (x : t (_ := i0)) => (y : t (_ := i1))
%%                     => (p : Heq x y) ≡> (i : I) ≡> t (_ := i)
\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Heq_uneq : (t : I @$\Rrightarrow$@ Type)
           @$\Rrightarrow$@ (x : t (_ := i0)) @$\Rightarrow$@ (y : t (_ := i1))
           @$\Rightarrow$@ (p : Heq x y) @$\Rrightarrow$@ (i : I) @$\Rrightarrow$@ t (_ := i)
\end{minted}

The composition of $\id{Heq\_uneq}$ and $\id{Heq\_eq}$ (modulo the implicit
arguments) is equal to the identity function, which gives us the
$\eta$-equivalence for some $\fn{p:Heq ?x ?y}$:

\begin{align*}
  & \Funapp{\id{Heq\_eq}}{(\earg{f}{\lambda i \Rrightarrow
      \Funapp{\id{Heq\_uneq}}{(\earg{p}{p})}{(\earg{i}{i})}})} = p
\end{align*}

\subsubsection*{Reduction rules}

\begin{prooftree*}
   \infer0[UNEQ-LEFT]{\Funapp{\id{Heq\_uneq}}{\id{x}}{\id{y}}{\id{p}}{\ileft}
                     \rightsquigarrow \id{x}}
\end{prooftree*}

\begin{prooftree*}
   \infer0[UNEQ-RIGHT]{\Funapp{\id{Heq\_uneq}}{\id{x}}{\id{y}}{\id{p}}{\iright}
                       \rightsquigarrow \id{y}}
\end{prooftree*}

When $\fn{Heq\_uneq}$ is called with canonical values of $\bI$, it reduces to
the corresponding endpoint of the equality proof. This is a crucial property
that allows derive theorems such as functional extensionality in
\autoref{subsec:funext}.

\subsection{Homogeneous equality}
Homogeneous equality is by far the more typical notion of equality. We are able
to define it as a special case of heterogeneous equality as a special case of of
$\fn{Heq x y}$ where $\fn{x}$ and $\fn{y}$ are of the same type.

%% Eq_uneq : (l : TypeLevel) ≡> (t : Type_ l)
%%           ≡> (x : t) => (y : t)
%%           => (p : Eq x y) ≡> (i : I) ≡> t
%% Eq_uneq = lambda _ ≡> lambda t ≡>
%%             lambda _ => lambda _ =>
%%               lambda p ≡> lambda i ≡>
%%                 Heq_uneq (t := lambda _ ≡> t) (p := p) (i := i)
\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq : (t : Type) @$\Rrightarrow$@ t @$\rightarrow$@ t @$\rightarrow$@ Type
Eq x y = Heq (t := lambda _ @$\Rrightarrow$@ t) x y

Eq_eq : (t : Type) @$\Rrightarrow$@ (f : I @$\Rrightarrow$@ t)
        @$\Rrightarrow$@ Eq (t := t) (f (_ := @$\ileft$@)) (f (_ := @$\iright$@))
Eq_eq t f = Heq_eq (t := @$\lambda$@ _ @$\Rrightarrow$@ t) (f := f)

Eq_uneq : (t : Type) @$\Rrightarrow$@ (x : t) @$\Rightarrow$@ (y : t) @$\Rightarrow$@ (p : Eq x y)
          @$\Rrightarrow$@ (i : I) @$\Rrightarrow$@ t
Eq_uneq p i = Heq_uneq (t := @$\lambda$@ _ @$\Rrightarrow$@ t) (p := p) (i := i)
\end{minted}

\section{Examples}\label{sec:eq-examples}
Common properties of the equality type remain true, some of them are easier to prove than with a traditional equality type.

\subsection*{Reflexivity}
A reflexive equality is the most trivial equality that we can construct, and
indeed, it is the one that we can construct with an erasable function out of
$\bI$ given that such a function is necessarily a constant function.

%% Eq_refl : (l : TypeLevel) ≡> (t : Type_ l)
%%            ≡> (x : t) ≡> Eq x x
%% Eq_refl = lambda _ ≡> lambda _ ≡> lambda x ≡>
%%             Eq_eq (f := lambda _ ≡> x)
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_refl : (x : ?t) |$\Rrightarrow$| Eq x x
Eq_refl x = Eq_eq (f := |$\lambda$| _ |$\Rrightarrow$| x)
\end{minted}

\subsection*{Commutativity}
This is the first of many properties that can be proved elegantly by defining
the equality type based on functions out of the interval. This property has many
names, such as the commutativity of equality, the symmetry of equality, or the
inversion of a path. Consider an equality between $\id{x}$ and $\id{y}$, we can
think of the two terms as points, the equality itself can then be thought of as
a continuous path between the two points. We think of the path as a directed
path from $\id{x}$ to $\id{y}$. The commutativity of equality means that we can
construct a path that goes in the opposite direction, in other words, we can
invert the path. This is the intuition behind the following proof.

%% Eq_comm : (x : ?t) ≡> (y : ?t) ≡> Eq x y -> Eq y x
%% Eq_comm p = Eq_eq (f := lambda i ≡> Eq_uneq (p := p) (i := I_not i))
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_comm : (x y : ?t) |$\Rrightarrow$| Eq x y |$\rightarrow$| Eq y x
Eq_comm x y = Eq_eq (f := |$\lambda$| i |$\Rrightarrow$| Eq_uneq (p := p) (i := !i))
\end{minted}

\begin{figure}[H]
\centering
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Ellipse [id:dp7216176657267284]
\draw   (220,155) .. controls (220,113.58) and (275.96,80) .. (345,80) .. controls (414.04,80) and (470,113.58) .. (470,155) .. controls (470,196.42) and (414.04,230) .. (345,230) .. controls (275.96,230) and (220,196.42) .. (220,155) -- cycle ;
%Shape: Circle [id:dp028557385614719877]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (262,153.33) .. controls (262,150.56) and (264.24,148.33) .. (267,148.33) .. controls (269.76,148.33) and (272,150.56) .. (272,153.33) .. controls (272,156.09) and (269.76,158.33) .. (267,158.33) .. controls (264.24,158.33) and (262,156.09) .. (262,153.33) -- cycle ;
%Shape: Circle [id:dp44344880871890213]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (420,153) .. controls (420,150.24) and (422.24,148) .. (425,148) .. controls (427.76,148) and (430,150.24) .. (430,153) .. controls (430,155.76) and (427.76,158) .. (425,158) .. controls (422.24,158) and (420,155.76) .. (420,153) -- cycle ;
%Curve Lines [id:da7287709889449594]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (267,153.33) .. controls (297.69,181.71) and (370.52,184.94) .. (423.4,158.8) ;
\draw [shift={(425,158)}, rotate = 153.7] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da6566329581802051]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (425,153) .. controls (394.47,125.42) and (303.78,126.95) .. (268.57,147.38) ;
\draw [shift={(267,148.33)}, rotate = 327.9] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (438,143) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {y};
% Text Node
\draw (381,180) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\id{p}$};
% Text Node
\draw (248,141) node [anchor=north west][inner sep=0.75pt]   [align=left] {x};
% Text Node
\draw (311,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\sim \id{p}$};

\end{tikzpicture}

\caption{A path from x to y along with its inversion}
\end{figure}

\subsection*{Functional extensionality}\label{subsec:funext}
The notion of functional extensionality implies that pointwise-equal functions
are indeed equal. By postulating the existence of the $\type{Interval}$ type
along with an equality type that's based on it, functional extensionality can be
derived trivially as is illustrated by the below proof.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_funExt : (f : (? |$\rightarrow$| ?)) |$\Rightarrow$| (g : (? |$\rightarrow$| ?))
            |$\Rightarrow$| (p : (x : ?) |$\rightarrow$| Eq (f x) (g x)) |$\rightarrow$| Eq f g
Eq_funExt p = Eq_eq (f := |$\lambda$| i |$\Rrightarrow$| |$\lambda$| x |$\rightarrow$|
                                   Eq_uneq (p := p x) (i := i))
\end{minted}

We note that the above proof makes use of the $\eta$-equivalence of functions,
i.e. $\lambda \id{x} \rightarrow \Funapp{\id{f}}{\id{x}} \equiv \id{f}$. Another
thing that is worth noting is that we interpret erasable functions out of $\bI$
themselves as an equality type, i.e.\ if we do without the $\id{Eq\_eq}$
constructor, and if we think of $\id{Eq\_uneq}$ as the direct application of an
expression of type $\bI$ to such a function, we obtain the following
interpretation of $\id{Eq\_funExt}$ as is the case in Cubical Agda.

\begin{minted}[escapeinside=||,mathescape=true]{agda}
funExt : |$\forall$| {A B : Type |$\ell$|} {f g: A |$\rightarrow$| B}
         |$\rightarrow$| (p : (x : A) |$\rightarrow$| f x |$\equiv$| g x)
         |$\rightarrow$| f |$\equiv$| g
funExt p i x = p x i
\end{minted}

The proof $\id{p}$ that the functions are extensionally equal may be seen to
have the type $\id{A} \rightarrow \bI \rightarrow B$, on other hand, a proof
that the functions are equal would have the type $\bI \rightarrow (A \rightarrow
B)$. In this case, it becomes clear that a proof of functional extensionality
merely needs to swap the order of its two arguments. This is observed in several
recent proof assistants that implement cubical type theory, such as Cubical Agda
as mentioned before, as well as coolTT and redTT.\@

Functional extensionality is a property that often makes an appearance in
mathematical proofs, it will especially be required to prove the effectiveness
of quotients in \autoref{ch:quotient-effectiveness}. However, as we shall see in
\autoref{sec:quot-implies-funext}, the existence of quotient types itself is
sufficient to derive functional extensionality.

It is also worth mentioning that unlike the traditional approach of adding
functional extensionality to an ITT as an axiom, canonicity is not broken by our
approach since the property is derived as a theorem. For instance, the example
given in\cite{altenkirch2007observational} is not a problem in our system as
performing a cast on an equality proof constructed by functionality
extensionality does not lead to a stuck term as shown in the following code snippet:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
plus0 : (x : Nat) -> zero + x @$\equiv$@ x + zero
plus0 x = Nat+_comm zero x

eqf = Eq_funext (f := lambda x -> zero + x)
                (g := lambda x -> x + zero)
                plus0

canon0 : Eq_cast (p := eqf) (f := lambda _ -> Nat) zero @$\equiv$@ zero
canon0 = Eq_refl
\end{minted}

\subsection*{Congruence of equality}\label{subsec:congruence-eq}
This is another typical property of equality whose proof is significantly
simplified in a system with a cubical equality.

%% Eq_cong : (x : ?A) => (y : ?A) =>
%%           (f : ?A -> ?) -> (p : Eq x y)
%%           -> Eq (f x) (f y)
%% Eq_cong = lambda f -> lambda p ->
%%             Eq_eq (f := lambda i ≡> f (Eq_uneq (p := p) (i := i)))
\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_cong : (x y : ?A) |$\Rightarrow$| (f : (?A |$\rightarrow$| ?)) |$\rightarrow$| (p : Eq x y)
          |$\rightarrow$| Eq (f x) (f y)
Eq_cong f p = Eq_eq (f := |$\lambda$| i |$\Rrightarrow$| f (Eq_uneq (p := p) (i := i)))
\end{minted}


Like before, we examine the definition of the theorem in Cubical Agda for a
change of perspective. We observe that the congruence of equality merely
involves applying the function $\id{f}$ to the terms at both endpoints of the
equality.

\begin{minted}[escapeinside=||,mathescape=true]{agda}
congS : |$\forall$| {A B : Type |$\ell$|} |$\rightarrow$| (f : A |$\rightarrow$| B) (p : x |$\equiv$| y) |$\rightarrow$| f x |$\equiv$| f y
congS f p i = f (p i)
\end{minted}

By appealing to the $\eta$-equivalence of the equality type described in
\autoref{sec:identity}, we also have that $\fn{Eq\_cong id p $\equiv$ p}$ holds
definitionally.

\subsection*{Transport}
The transport operation (also known as {\id{cast}}) allows us to transport
properties that are true for some type $\id{A}$ to another type $\id{B}$ if we
have a proof that $\eqtype{\id{A}}{\id{B}}$.

%% Eq_cast : (x : ?) ≡> (y : ?) ≡> (p : Eq x y) ≡> (f : ? -> ?)
%%             ≡> f x -> f y
%% Eq_cast = lambda _ ≡> lambda _ ≡> %% Two level variables
%%            lambda A ≡> %% Type of x and y
%%            lambda x ≡> lambda y ≡>
%%            lambda p ≡> lambda f ≡>
%%              lambda fx ->
%%                 I_transp (A := lambda i ≡> f (Heq_uneq
%%                                               (t := lambda _ ≡> A)
%%                                               (p := p) (i := i)))
%%                          (r := i0) fx
%%

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_cast : (x y : ?A) |$\Rrightarrow$| (p : Eq x y) |$\Rrightarrow$| (f : (? |$\rightarrow$| ?)) |$\Rrightarrow$| f x
          |$\rightarrow$| f y
Eq_cast A x y p f fx =
  I_transp (A := |$\lambda$| t |$\Rrightarrow$| f (Eq_uneq (t := t) (p := p) (i := i)))
           (r := |$\ileft$|) fx
\end{minted}

Here, we make use of the built-in function $\id{I\_transp}$ by passing it the
argument $\earg{\id{r}}{\ileft}$, intending it to behave as a transport
function. In other words, by passing it something of type
$\Funapp{\id{f}}{\id{x}}$, it returns something of type
$\Funapp{\id{f}}{\id{y}}$, which is precisely what the transport/cast function
is meant to do.

The $\id{I\_transp}$ function that looks slightly strange at first sight allows
us to prove a certain property of the transport operation. Transporting across a
reflexive path should be equivalent to a no-op, as illustrated in the
following proof.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_cast_refl : (A : Type) |$\Rrightarrow$| (x : A)
               |$\rightarrow$| Eq (Eq_cast (p := Eq_refl (x := x))
                              (f := |$\lambda$| _ |$\rightarrow$| A) x)
                     x
Eq_cast_refl A x = Eq_eq (f := |$\lambda$| i |$\Rrightarrow$|
                            I_transp (A := |$\lambda$| _ |$\Rrightarrow$| A) (r := i) x)
\end{minted}


In Typer and in intensional type theory in general, we need to explicitly invoke
a cast function of some sort, this is in contrast with extensional type theory
(ETT)\cite{martin1982constructive} where equality proofs in the context are
automatically used by the type-checker to carry out casts whenever necessary.
This is shown by the following judgement in ETT that states that equality proofs
can be converted to judgemental equalities.

\begin{prooftree*}
  \hypo{\oftype{\ctx}{t}{\Funapp{\kw{Eq}}{a}{b}}}
  \infer1{\ctx \vdash a \simeq b}
\end{prooftree*}

This is also the reason why type-checking is not decidable in ETT as the
necessity to invoke the above rule is not syntax-directed.


\subsection*{J-rule}\label{subsec:j-rule}
The sole term former of the $\kw{Eq}$ only allows the construction of reflexive
equalities, at first sight, this leads us to believe that not much can actually
be done with the $\kw{Eq}$ type. After all, if all we had were proofs of the
form $x = x$, it would be difficult to imagine achieving anything with them. The
true magic of the equality type lies in its elimination principle.
Traditionally, the equality type comes with an elimination principle known as
the J-rule. This was first introduced by Per Martin-Löf
in\cite{martin1975intuitionistic}. Suppose that we have a type family $C$ that
is parametrised by two terms $x$ and $y$ of some type $A$ as well as a proof
that $x$ and $y$ are equal, i.e.\ of type $\Funapp{\kw{Eq}}{x}{y}$. If we have
a proof term $p$ that witnesses the equality of two arbitrary terms $a$ and
$b$ of type $A$, and we wish to produce a term of type $\Funapp{C}{a}{b}{p}$,
then the J-rule says that it suffices for us to provide a means of producing for
all $\oftype{x}{A}$ a term of type $\Funapp{C}{x}{x}{(\Funapp{\kw{refl}}{x})}$.
We now state the type of the J-rule:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
J : (A : Type) @$\Rrightarrow$@ (C : (x : A) @$\rightarrow$@ (y : A) @$\rightarrow$@ Eq x y @$\rightarrow$@ Type)
    @$\Rrightarrow$@ ((x : A) @$\rightarrow$@ C x x Eq_refl)
    @$\rightarrow$@ (x : A) @$\rightarrow$@ (y : A) @$\rightarrow$@ (p : Eq x y)
    @$\rightarrow$@ C x y p;
\end{minted}

This rule is essentially saying that to know what to do with an
equality between an arbitrary $x$ and $y$, we merely need to know how to handle
the case where we are dealing with a reflexivity proof. Now, given the fact that the
reflexivity constructor is the only constructor of the $\kw{Eq}$ type, one might
think that the above elimination principle is well justified. Recall that
the elimination principle of strictly positive types\cite{abbott2005containers} can
usually be derived based on the constructors of the datatype itself. For
instance, consider the below inductive definition of the Peano natural numbers.

\begin{minted}{haskell}
type Nat
    | zero
    | succ Nat
\end{minted}

The corresponding elimination principle then takes on the following logical form:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Nat_elim : (P : Nat @$\rightarrow$@ Type)
           @$\Rrightarrow$@ P zero @$\rightarrow$@ ((n : Nat) @$\rightarrow$@ P n @$\rightarrow$@ P (succ n))
           @$\rightarrow$@ (n : Nat) @$\rightarrow$@ P n;
\end{minted}

First, we need to define what needs to be done if the natural number we are
trying to eliminate is $\id{zero}$. Next, if the natural number we want to
eliminate is something of the form $\Funapp{succ}{n}$, then we can imagine
making a recursive call to the eliminator to produce a result for
$\Funapp{succ}{n}$ for $n$, and now we need a means of transforming a proof of
$\Funapp{P}{n}$ to one of $\Funapp{P}{(\Funapp{succ}{n})}$. Indeed, the
elimination principle of natural numbers is just mathematical induction. Hence,
it is reasonable to say that in order to eliminate an equality proof, it
suffices for us define what needs to be done for reflexivity proofs.

In Typer, the elimination rule for the $\kw{Eq}$ type was not provided in the
form of the J-rule prior to this work, instead a cast function was provided as
mentioned in a previous section. It is possible to derive $\kw{Eq\_cast}$ from
the J-rule. The natural question that we should now ask ourselves is whether the
J-rule can be derived from $\kw{Eq\_cast}$, in other words we would like to know
if the two elimination principles are equivalent. It turns out that one way of
doing it hinges upon whether we are able to inhabit the following type:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
eqUnique : (A : Type) @$\Rrightarrow$@ (a b : A) (p : Eq a b)
           @$\rightarrow$@ Eq (t := Sigma A (lambda a' -> Eq a a'))
                               (sigma a Eq_refl) (sigma b p);
\end{minted}

This can be seen as a justification of the J-rule, by fixing one endpoint of an
equality proof to be $\fn{a}$, it is provable that any equality proof between
$\fn{a}$ and some other arbitrary $\fn{b}$ may be proved to be equal to the
reflexivity proof at $\fn{a}$. More details are given in
\autoref{subsec:interval-connections} on how to construct the above. Once we have that,
we may easily define the J-rule.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
J h x y p =
    Eq_cast (p := eqUnique p)
            (f := lambda e @$\rightarrow$@ C x e.fst e.snd) (h x);
\end{minted}

\subsection*{Transitivity}\label{subsection:eqtransitivity}
Continuing our analogy of equality proofs as paths, the transitivity property allows us to concatenate two paths. We join the right endpoint of the first path with the left endpoint of the second path, producing a new path. The proof of this theorem is as follows:

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Eq_trans : (x y z: ?t) |$\Rrightarrow$| Eq x y |$\rightarrow$| Eq y z |$\rightarrow$| Eq x z
Eq_trans x y z x=y y=z = Eq_cast (p := y=z)
                                 (f := |$\lambda$| x' |$\rightarrow$| Eq x x')
                                 x=y
\end{minted}

\begin{figure}[H]
\centering
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Ellipse [id:dp014634117148388581]
\draw   (210,155) .. controls (210,113.58) and (265.96,80) .. (335,80) .. controls (404.04,80) and (460,113.58) .. (460,155) .. controls (460,196.42) and (404.04,230) .. (335,230) .. controls (265.96,230) and (210,196.42) .. (210,155) -- cycle ;
%Shape: Circle [id:dp26323124675512766]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (253,160.06) .. controls (253,157.3) and (255.24,155.06) .. (258,155.06) .. controls (260.76,155.06) and (263,157.3) .. (263,160.06) .. controls (263,162.82) and (260.76,165.06) .. (258,165.06) .. controls (255.24,165.06) and (253,162.82) .. (253,160.06) -- cycle ;
%Shape: Circle [id:dp6819431699402925]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (328,110.06) .. controls (328,107.3) and (330.24,105.06) .. (333,105.06) .. controls (335.76,105.06) and (338,107.3) .. (338,110.06) .. controls (338,112.82) and (335.76,115.06) .. (333,115.06) .. controls (330.24,115.06) and (328,112.82) .. (328,110.06) -- cycle ;
%Curve Lines [id:da09243595336985422]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (338,110.06) .. controls (364.73,112.97) and (388.52,119.86) .. (417.13,154.01) ;
\draw [shift={(418,155.06)}, rotate = 229.87] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Curve Lines [id:da576198955407853]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (258,160.06) .. controls (258.99,139.27) and (277.62,125.28) .. (326.51,110.51) ;
\draw [shift={(328,110.06)}, rotate = 163.36] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Circle [id:dp7540304044235371]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (413,160.06) .. controls (413,157.3) and (415.24,155.06) .. (418,155.06) .. controls (420.76,155.06) and (423,157.3) .. (423,160.06) .. controls (423,162.82) and (420.76,165.06) .. (418,165.06) .. controls (415.24,165.06) and (413,162.82) .. (413,160.06) -- cycle ;
%Curve Lines [id:da43079739398707617]
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (258,160.06) .. controls (302.55,202.13) and (372.58,201.57) .. (411.82,166.14) ;
\draw [shift={(413,165.06)}, rotate = 136.9] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (321,91) node [anchor=north west][inner sep=0.75pt]   [align=left] {y};
% Text Node
\draw (241,147.06) node [anchor=north west][inner sep=0.75pt]   [align=left] {x};
% Text Node
\draw (424,147.06) node [anchor=north west][inner sep=0.75pt]   [align=left] {z};

\end{tikzpicture}

\caption{The concatenation of a path between x and y and a path between y and z to produce a new path between x and z.}
\end{figure}

\subsection*{Connections}\label{subsec:interval-connections}

The operations that we defined on the Interval correspond to
connections\cite{cohen2016cubical} that are typically drawn as squares. Such
connections allow us to construct squares from paths by adding degeneracies.

\subsubsection*{Meet}

Suppose that we have some proof $\fn{p}$ between terms $\fn{a}$ and $\fn{b}$,
the interval meet operation allows us to construct a square that corresponds to
the following expression:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
sq = Eq_eq (f := @$\lambda$@ i @$\Rrightarrow$@ Eq_eq (f := @$\lambda$@ j @$\Rrightarrow$@ Eq_uneq (p := p) (i := I_meet i j)))
\end{minted}

In this square, the $\fn{i}$ direction goes from left to right and the
$\fn{j}$ direction goes from bottom to up. Each side of the square corresponds
to some equality proof. The top and right sides of the square are simply the
original proof $\fn{p}$. The left and bottom sides of the square are fixed to be
constant paths to and from the left endpoint of the proof $\fn{p}$. In other
words, they can be seen to be reflexivity proofs of $\fn{a}$. This is precisely
what we meant earlier by degeneracies as such paths are trivial.

%% FIXME: Bad alignment
\begin{center}
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Straight Lines [id:da5901241884786586]
\draw    (280.24,210.16) -- (280.24,82.66) ;
\draw [shift={(280.24,80.66)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da7023100749425399]
\draw    (430.35,210.41) -- (430.35,82.74) ;
\draw [shift={(430.35,80.74)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da5268427848389134]
\draw    (290.56,70.17) -- (418.62,70.17) ;
\draw [shift={(420.62,70.17)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da001913191488255972]
\draw    (290.56,220.6) -- (417.94,220.6) ;
\draw [shift={(419.94,220.6)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (275.39,61.32) node [anchor=north west][inner sep=0.75pt]   [align=left] {a};
% Text Node
\draw (274.93,211.14) node [anchor=north west][inner sep=0.75pt]   [align=left] {a};
% Text Node
\draw (425.64,62.29) node [anchor=north west][inner sep=0.75pt]   [align=left] {b};
% Text Node
\draw (425.64,210.47) node [anchor=north west][inner sep=0.75pt]   [align=left] {a};
% Text Node
\draw (175.25,141.25) node [anchor=north west][inner sep=0.75pt]  [font=\scriptsize] [align=left] {eq ($\displaystyle \lambda $ j $\displaystyle \Rrightarrow $uneq p $\displaystyle i_{0}$)};
% Text Node
\draw (347.5,57) node [anchor=north west][inner sep=0.75pt]  [font=\scriptsize] [align=left] {p};
% Text Node
\draw (436.75,134.75) node [anchor=north west][inner sep=0.75pt]  [font=\scriptsize] [align=left] {p};
% Text Node
\draw (308.25,133) node [anchor=north west][inner sep=0.75pt]  [font=\tiny] [align=left] {eq ($\displaystyle \lambda $ i $\displaystyle \Rrightarrow $eq \ ($\displaystyle \ \lambda $ j $\displaystyle \Rrightarrow $\\	uneq p ($\displaystyle i\ \land \ j$) )\\\\};
% Text Node
\draw (306.75,226.75) node [anchor=north west][inner sep=0.75pt]  [font=\scriptsize] [align=left] {eq ($\displaystyle \lambda $ i $\displaystyle \Rrightarrow $uneq p $\displaystyle i_{0}$)};

\end{tikzpicture}

\end{center}

To illustrate why the given square corresponds to the expression given above, we
shall examine each side of the square. Recalling the dimensions of the squares,
on the left side of the square, the dimension $\fn{i}$ is $i_0$. So we if we fix
$\fn{i}$ to be $i_0$ in $\fn{sq}$, the resulting expression is the following,
which we can reduce to the constant path on $\fn{a}$ by using the reduction
rules of $\fn{I\_meet}$ defined in \autoref{subsubsec:interval-meet}:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq_eq (f := @$\lambda$@ j @$\Rrightarrow$@ Eq_uneq (p := p) (i := I_meet @$i_0$@ j))
\end{minted}

For the bottom side, we fix $\fn{j}$ to be $i_0$ to obtain the below expression,
which is once again a constant path on $\fn{a}$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq_eq (f := @$\lambda$@ i @$\Rrightarrow$@ Eq_uneq (p := p) (i := I_meet i @$i_0$@))
\end{minted}

The right side requires us to fix $\fn{i}$ to be $i_1$, giving us the below
expression which simply reduces to $\fn{p}$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq_eq (f := @$\lambda$@ j @$\Rrightarrow$@ Eq_uneq (p := p) (i := I_meet @$i_1$@ j))
\end{minted}

By fixing $\fn{j}$ to be $i_1$, we get the expression that corresponds to the top side, which also reduces to $\fn{p}$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Eq_eq (f := @$\lambda$@ i @$\Rrightarrow$@ Eq_uneq (p := p) (i := I_meet i @$i_1$@))
\end{minted}

The construction of such a square is precisely what is required to
prove the $\fn{eqUnique}$ property mentioned in \autoref{subsec:j-rule}.

\subsubsection*{Join}

TODO:\ TBD if I want to do this. Joins could be used to build the same square
that we saw above, the only difference is that the added degeneracy would be
a refl path on $b$ instead of $a$. The thing is, I've never really needed
this.

\section{Equality as a mere proposition}
Although we say that our equality type is a proposition, it is by no means a
mere proposition (HoTT book\cite{HoTTbook} Chapter 3.3). This implies that it is
not a given that two proofs of the same equality are provably
equal\cite{hofmann1998groupoid}. In other words, when we ask ourselves the
question ``Is it the case that a = b'', we do not only care if the answer is yes
or no, if they are indeed equal, we can interest ourselves in what ways exactly
are they equal. This is in contrast to other systems where the Uniqueness of
Identity Proofs principle (UIP) applies to all types. Notably, this is true of
systems that admit axiom K\cite{streicher1993investigations} that states all
identity proofs are equal to the reflexivity proof, and by extension all proofs
of the same equality are equal. In the remainder of this section, we show that
UIP is a property that is true for a certain class of types in Typer.

\subsection{Hedberg's theorem}\label{subsec:hedberg}

To set the stage, we provide a few definitions. A type is said to be
\textbf{decidable} if we can decide whether the type is inhabited or
not. In the case where it is inhabited, we must also have a witness of such an
inhabitant. In Typer, decidability can be represented by the following inductive
type.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
type Dec (A : Type)
  | yes A
  | no (A -> False)
\end{minted}

A type is said to be \textbf{collapsed} if any two inhabitants of the type may
be proved to be equal, this corresponds directly to the notion of a mere
proposition. The two definitions that we just stated may also be used in the
context of identity types. If we say that a type has decidable equality,
this implies that for any two terms of this type, we can decide whether or not
they are equal. On top of that, if the type has collapsed identity types, then
for any pair of terms of this type, any two proofs that they are equal are also
equal. The notion of collapsible identity types corresponds to the notion of a
$\kw{Set}$ or h-set in HoTT.

\begin{theo}[Hedberg's theorem\cite{hedberg1998coherence}]
If a type \fn{A} has decidable equality, then \fn{A} has collapsed identity
types.
\end{theo}

In this work, we provide a proof of this theorem in the form of Typer code. We
present the type of the function without going into the details of its
implementation\footnote{The actual implementation may be found in the attached \fn{samples/hedberg.typer} file}.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
dici : (di : (x : ?A) @$\rightarrow$@ (y : ?A) @$\rightarrow$@ Dec (x @$\equiv$@ y))
       @$\rightarrow$@ (a : ?A) @$\rightarrow$@ (b : ?A)
       @$\rightarrow$@ (u : a @$\equiv$@ b) @$\rightarrow$@ (v : a @$\equiv$@ b)
       @$\rightarrow$@ u @$\equiv$@ v
\end{minted}

\section{Limitations}
We don't have primitives such as $hcomp$, what does this imply? Is there a
certain class of proofs we are unable to construct? Or do we just suffer from
some amount of inconvenience?


\chapter{Quotient Type}\label{ch:quot}
\section{Typing rules}
We present the $\id{Quotient}$ primitives along with their typing rules.

\begin{prooftree*}
   \hypo{\oftype{\ctx}{\id{A}}{\kw{Type}}}
   \hypo{\oftype{\ctx}{\id{R}}{\id{A} \rightarrow \id{A} \rightarrow \kw{Type}}}
   \infer2[\kw{QUOT-FORMATION}]{\oftype{\ctx}{\Funapp{\kw{Quotient}}{\id{A}}{\id{R}}}
                                             {\kw{Type}}}
\end{prooftree*}

We introduce the $\kw{Quotient}$ type former, which takes a base type $\id{A}$
along with a relation $\id{R}$ as arguments. At this stage, just like
in\cite{hofmann1995simple}, we do not require the relation to be an equivalence
relation, though to define a meaningful quotient type, the above
requirement is often necessary. We also do not enforce that the relation be a
mere proposition, however as we will see in \autoref{ch:quotient-effectiveness},
this is required for the quotient to be effective.

\begin{prooftree*}
   \hypo{\oftype{\ctx}{\id{a}}{\id{A}}}
   \hypo{\oftype{\ctx}{\Funapp{\id{Quotient}}{\id{A}}{\id{R}}}
                      {\kw{Type}}}
   \infer2[\kw{QUOT-INTRO-IN}]{\oftype{\ctx}{\Funapp{\id{Quotient\_in}}{\id{A}}{\id{R}}{\id{a}}}
                                         {\Funapp{\id{Quotient}}{\id{A}}{\id{R}}}}
\end{prooftree*}

$\id{Quotient\_in}$ is none other than a term former that acts as the canonical
surjection of a term of type $\id{A}$ into a quotient under some relation.

\begin{prooftree*}
   \hypo{\oftype{\ctx}{\id{a}_1}{\id{A}}}
   \hypo{\oftype{\ctx}{\id{a}_2}{\id{A}}}
   \hypo{\oftype{\ctx}{\id{r}}{\Funapp{\id{R}}{\id{a}_1}}{\id{a}_2}}
   \infer3[\kw{QUOT-INTRO-EQ}]{
\oftype{\ctx}{\Funapp{\id{Quotient\_eq}}{\id{A}}{\id{R}}
                                        {\id{a}_1}{\id{a}_2}{\id{r}}}
             {\Funapp{\id{Quotient\_in}}{\id{A}}{\id{R}}{\id{a}_1} \equiv \Funapp{\id{Quotient\_in}}{\id{A}}{\id{R}}{\id{a}_2}}}

\end{prooftree*}

By definition, given that two terms $\id{a}_1$ and $\id{a}_2$ of type $\id{A}$
are related by some relation, then the surjections of these two terms into a
quotient under the aforementioned relation should be equal. $\id{Quotient\_eq}$
is a witness of the above property.

\begin{prooftree*}
   \hypo{\oftype{\ctx}{\id{P}}{\Funapp{\id{Quotient}}{\id{A}}{\id{R}} \rightarrow \kw{Type}}}
   \hypo{\oftype{\ctx}{\id{q}}{\Funapp{\id{Quotient}}{\id{A}}{\id{R}}}}
   \infer[no rule]2{\oftype{\ctx}{\id{f}}
                           {(\oftype{\id{a}}{\id{A}}) \rightarrow \Funapp{\id{P}}{(\Funapp{\id{Quotient\_in}}{\id{A}}{\id{R}}{\id{a}})}}}
   \infer[no rule]1{\oftype{\ctx}{\id{h}}{(\oftype{\id{a}_1 \ \id{a}_2}{\id{A}})
                                          \rightarrow \Funapp{\id{R}}{\id{a}_1}{\id{a}_2}}
                                          \rightarrow \Funapp{\id{Heq}}{(\Funapp{\id{f}}{\id{a}_1})}
                                                                       {(\Funapp{\id{f}}{\id{a}_2})}}
   \infer1[\kw{QUOT-ELIM}]{\oftype{\ctx}{\Funapp{\id{Quotient\_elim}}{\id{A}}{\id{R}}{\id{f}}{\id{h}}{\id{q}}}
                                        {\Funapp{\id{P}}{\id{q}}}}
\end{prooftree*}

We would like to enable the dependent elimination of quotients, in other words
we would like to be able to eliminate a term of some quotient type
$\Funapp{\id{Quotient}}{\id{A}}{\id{R}}$ to some type family $\id{P}$ that is
indexed by the quotient type itself. To that end, we require some function
$\id{f}$ that takes some $\id{a}$ of the base type $\id{A}$ to
$\Funapp{\id{P}}{(\Funapp{\id{Quotient\_in}}{\id{A}}{\id{R}}{\id{a}})}$. In a
way, this implies that the function $\id{f}$ has the chance of `looking inside'
the quotient, and thus we also require a proof that such a function $\id{f}$
behaves consistently when applied to terms that are related by the underlying
relation of the quotient. The usage of heterogeneous equality here is necessary
as $\Funapp{\id{f}}{\id{a}_1}$ and $\Funapp{\id{f}}{\id{a}_2}$ are not of the
same type. We note as well that our dependent elimination of quotients is not
limited to motives that are \type{Props}, as opposed to when quotient types are
added to a theory interpreted in a setoid model as proposed by
Li\cite{li2015quotient}.

\section{Reduction rules}
We present the computation rule for the elimination of quotients.

\begin{prooftree*}
   \hypo{\id{q} \rightsquigarrow \Funapp{\id{Quotient\_in}}{\id{A}}{\id{R}}{\id{a}}}
   \infer1[]{\Funapp{\id{Quotient\_elim}}{\id{A}}{\id{R}}{\id{f}}{\id{h}}{\id{q}}
             \rightsquigarrow \Funapp{\id{f}}{\id{a}}}
\end{prooftree*}

We note that during $\id{Quotient}$ elimination, the proof that the eliminator
function respects the $\id{Quotient}$ is ignored. Instead, the function is
applied directly to the underlying element of the base type. The fact that the
proof that the elimination respects the quotient is unused during computation
and is merely utilised during type-checking justifies our subsequent choice of
making the proof an erasable argument of $\id{Quotient\_elim}$.

It is also interesting to note that we are not able to derive a meaningful
$\eta$-rule. If we wish to apply $\id{Quotient\_in}$ after applying
$\id{Quotient\_elim}$ such that the composition amounts to the identity
function, this would imply that $\id{Quotient\_elim}$ would need to called with
a function $\id{f}$ such that \fn{$\forall$ a. R a (f a)} is valid.
Unfortunately, in the general case, this would not respect the underlying
relation of the quotient.

\section{Implementation}

In this section, we describe how the rules described above were added to Typer.
Subsequently, we describe the library that we provide to facilitate the usage of
quotient types in the development of Typer programs and proofs.

\subsection{Axioms}

Quotient types are introduced in Typer in an axiomatic manner, i.e.\ the existence
of the type former, terms formers and eliminators are simply postulated.
However, the appropriate computational behaviour of the above constructs are
also added to the system whenever necessary such that we do not find ourselves
with stuck terms that adversely affect the computational properties of our
system.

\subsubsection*{Formation}
The existence of the $\id{Quotient}$ type is postulated as follows:

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Quotient : (A : Type) |$\rightarrow$| (R : A |$\rightarrow$| A |$\rightarrow$| Type) |$\rightarrow$| Type
\end{minted}

\subsubsection*{Introduction}
Two axioms are added, corresponding to the two introduction rules of $\id{Quotient}$.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Quotient_in : (A : Type) |$\Rrightarrow$| (R : A |$\rightarrow$| A |$\rightarrow$| Type) |$\Rrightarrow$| A |$\rightarrow$| Quotient A R
Quotient_eq : (A : Type) |$\Rrightarrow$| (R A |$\rightarrow$| A |$\rightarrow$| Type)  |$\Rrightarrow$| (a a' : A) |$\Rrightarrow$| R a a'
              |$\rightarrow$| Eq (Quotient_in (R := R) a) (Quotient_in (R := R) a')
\end{minted}

As a constructor of equalities, $\id{Quotient\_eq}$ does not take part in
computations. As such, no special reduction rules needed to be added for it.

\subsubsection*{Elimination}

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Quotient_elim : (A : Type) |$\Rrightarrow$| (R : A |$\rightarrow$| A |$\rightarrow$| Type) |$\Rrightarrow$| (P : Quotient A R |$\rightarrow$| Type)
                |$\Rrightarrow$| ((a : A) |$\rightarrow$| P (Quotient_in a))
                |$\rightarrow$| ((a a' : A) |$\rightarrow$| R a a' |$\rightarrow$| Heq (f a) (f a'))
                |$\Rrightarrow$| (q : Quotient A R) |$\rightarrow$| P q
\end{minted}

As mentioned in the previous section, the appropriate $\beta$-reduction rule is
added for the eliminator. When $\id{Quotient\_elim}$ is passed a term of the
form $\Funapp{\id{Quotient\_in}}{\id{a}}$, the entire $\id{Quotient\_elim}$ term
reduces to just $\Funapp{\id{f}}{\id{a}}$, ignoring the coherence proof that is
passed to the function as it acts simply as a form of static information.

\subsection{Syntactic sugar}

\subsubsection*{qcase}

We provide some syntactic sugar to simplify the non-dependent elimination
quotients. The syntax we opted for is reminiscent of that of
Arend's\cite{arend}. The elimination of a quotient expression is done in the
style of a case analysis where both the term and path constructors have to be
addressed with the following syntax:

\begin{minted}{haskell}
qcase q
  | Quotient_in a => e1
  | Quotient_eq x y r => e2;
\end{minted}

\id{q} is the scrutinee of the case analysis. A type annotation may be given to it
by specifying the base type and relation of the quotient, e.g. \fn{(e: A / R)}.
The variable \id{a} is defined in the scope of \id{e1} and the variables \id{x},
\id{y}, and \id{r} are defined in the scope of \id{e2}. The bound variables are
the parameters of the two constructors of \id{Quotient}. In the first branch, we
say what we would like to map a quotient expression to. In the second branch, we
prove that the above mapping respects the quotient by constructing a term
\fn{e2: [x/a]e1 $\equiv$ [y/a]e2}.

To illustrate how this works, we construct an simple example based on the
quotient of the \id{Unit} type along with a total relation \id{R} defined on
\id{Unit}. We define a function of type \fn{Quotient Unit R $\rightarrow$ Unit}.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
R : Unit @$\rightarrow$@ Unit @$\rightarrow$@ Type
R u1 u2 = Unit

e1 : Quotient Unit R @$\rightarrow$@ Unit
e1 q = qcase (q : Unit / R)
        | Quotient_in a @$\Rightarrow$@ ()
        | Quotient_eq a a' r @$\Rightarrow$@ Eq_refl
\end{minted}

Drawing inspiration from Arend, the \id{Quotient\_eq} branch may also be handled
by introducing an Interval variable into the scope. Instead of directly
constructing an equality proof, we simply specify what the given map for the
\id{Quotient\_in} branch would map us to for a certain endpoint \id{i}. We may
rewrite the above example as follows:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
e2 : Quotient Unit R @$\rightarrow$@ Unit
e2 q = qcase (q : Unit / R)
        | Quotient_in a @$\Rightarrow$@ ()
        | Quotient_eq a a' r i @$\Rightarrow$@ ()
\end{minted}

More elaborate examples of usages of this macro are given in subsequent
sections.

\subsubsection*{Encoding of Quotient Inductive Types}

We initially intended to encode QITs as quotient types with the help of a macro.
Such an encoding is without a doubt possible, in \autoref{sec:multiset} and
\autoref{sec:related-qit} we shall see the \id{Multiset} data type defined both
as a quotient type and as a quotient inductive type. One could imagine that the
translation of the latter version to the former may be done by repackaging the
path constructors introduced by the QIT as constructors of a new relation over
which we shall construct a new quotient type. However, as will be mentioned in
\autoref{sec:multiset}, such a relation is not necessarily an equivalence
relation. In the aforementioned section, we solved the problem by taking
reflexive, symmetric, and transitive closure of the relation. However, such a
construction is a tough ask for a macro. Hence, we ultimately decided to abandon
this idea as even if such a macro were to come to fruition, it would most likely
be user-unfriendly.

\chapter{Quotient Effectiveness}\label{ch:quotient-effectiveness}

This only works for relations that are propositions and equivalence relations
(i.e.\ reflexive, symmetric and transitive).

\section{Propositional Extensionality}
We provide a alternative version of propositional extensionality that is
slightly weaker. Consequently, the version of quotient effectiveness that we
prove is also weaker.

\subsection*{Representation of propositions}\label{subsec:mere-propositions}

Intuitively speaking, propositions are a type that contain no intrinsic data, it
is their mere existence that counts. This is precisely the notion of proof
irrelevance. In Typer, this notion is represented via erasability. We introduce
a built-in data type that captures this idea.

\begin{minted}{haskell}
type Erased (T : Type)
  | erased (t ::: T)
\end{minted}

By ensuring that the witness $\id{t}$ of the type $\id{T}$ is erasable, this
provides us with a guarantee that during elimination, the witness $\id{t}$ can
only be used in an erasable, i.e.\ proof irrelevant manner.

To convince ourselves that this type does indeed capture the essence of a
proposition, we provide a proof of
$\Funapp{\id{isProp}}{(\Funapp{\id{Erased}}{?\id{T}})}$. We first state the
definition of $\id{isProp}$:

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
isProp : (T : Type) |$\rightarrow$| Type
isProp T = (x y : T) |$\rightarrow$| Eq x y
\end{minted}

We now the present the proof in the form of Typer code.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
erasedIsProp : (T : Type) @$\Rrightarrow$@ isProp (Erased T)
erasedIsProp t1 t2 =
  case t1
    | erased (_ := e1) @$\Rightarrow$@
        let
          p1 = ##DeBruijn 0 : Eq (erased (t := e1)) t1
        in
          case t2
            | erased (_ := e2) @$\Rightarrow$@
                let
                  p2 = ##DeBruijn 0 : Eq (erased (t := e2)) t2
                in
                  Eq_trans (Eq_comm p1) p2
\end{minted}

Typer does not offer the direct specialisation of $\kw{case}$ targets in
branches. In other words, in the first case branch, we do not have a
definitional equality between $\id{t1}$ and
$\Funapp{\id{erased}}{(\earg{\_}{\id{e1}})}$. Instead, an equality proof between
them is injected into the context, which can be accessed as the variable at
deBruijn index 0. Now that we have the two equality proofs, in order to
concatenate them\footnote{By considering equalities as path, the application of
the transitivity property of equality is conceptually similar to concatenating
two paths.}, we require $\Funapp{\id{erased}}{(\earg{\_}{\id{e1}})}$ and
$\Funapp{\id{erased}}{(\earg{\_}{\id{e2}})}$ to be equal. A priori, the two
terms are not equal as $\id{e1}$ and $\id{e2}$ are completely arbitrary.
However, Typer ignores erasable terms when checking the convertibility of terms,
this is a property that was proven to be sound in\cite{barras2008implicit} as
convertibility is tested on extracted terms. This allows the concatenation to
succeed and thus concludes the proof.

\subsection*{Implementation details}

Propositional extensionality essentially means that if two propositions that are
logically equivalent, i.e.\ each proposition implies the other, then we can say
that they are equal. And precisely because we are postulating a new equality
constructor, we have to be very careful that the resulting equality proof is
indeed proof irrelevant. In other words, we need this equality proof to not have
any runtime relevance. This is principally because we insist that the transport
operation to be a no-op during runtime. This is the motivation behind our choice
to use the $\id{Erased}$ type to represent propositions, as it is a guarantee
that such a type carries no useful runtime information. This implies that a
transport operation from one $\id{Erased}$ type to another is necessarily simply
a no-op.

In a setting with univalence, propositional extensionality is simply a theorem
that may be proven, more specifically, it may be seen as a degenerate case of univalence\cite{sozeau2013univalence}. This is a result that is
immediate as an equivalence between logically equivalent propositions is
trivial. In the setting of Typer however, propositional extensionality is
implemented as an axiom with the following type signature:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
propExt : (A : Type) @$\Rrightarrow$@ (B : Type) @$\Rrightarrow$@ (Erased A @$\rightarrow$@ Erased B)
           @$\rightarrow$@ (Erased B @$\rightarrow$@ Erased A) @$\rightarrow$@ Erased A \equiv Erased B
\end{minted}

The above is a weaker notion of propositional extensionality compared to what is
proposed in Cubical Agda, which has the following type signature:

\begin{minted}[escapeinside=@@,mathescape=true]{Agda}
propExt : {A B : Type} @$\rightarrow$@ isProp A @$\rightarrow$@ isProp B @$\rightarrow$@ (A @$\rightarrow$@ B)
          @$\rightarrow$@ (B @$\rightarrow$@ A) @$\rightarrow$@ A @$\equiv$@ B
\end{minted}

However, this produces an equality proof that is not proof irrelevant, as
$\id{A}$ and $\id{B}$ are not necessarily the \emph{same} type. We illustrate
the above with a simple example. We define two instances of the unit type which
are trivially \emph{logically equivalent}.

\begin{minted}[escapeinside=@@,mathescape=true]{Agda}
data Unit1 : Type where unit1 : Unit1

data Unit2 : Type where
  unit2 : Unit2
\end{minted}

$\Funapp{\kw{isProp}}{\id{Unit1}}$ and $\Funapp{\kw{isProp}}{\id{Unit2}}$ are
trivially true, as is the case for all $\mathbb{1}$-types. $\id{Unit1}
\rightarrow \id{Unit2}$ and $\id{Unit2} \rightarrow \id{Unit1}$ are also
inhabited. Propositional extensionality thus gives us a proof of $\id{Unit1}
\equiv \id{Unit2}$. This implies that we should be able to use said proof to
transport $\id{unit1}$ to $\id{unit2}$, but since the two terms do not have the
same runtime representation, this simply cannot be a no-op. This is in stark
contrast to the version of propositional extensional that we are proposing in
Typer that only accepts types that are boxed in the $\id{Erased}$ type. We would
have no qualms about having a proof of equality between
$\Funapp{\id{Erased}}{Unit1}$ and $\Funapp{\id{Erased}}{Unit2}$ as terms of
these two types would essentially have the same runtime representation. It is
also for this precise reason that our version of propositional extensionality is
weaker, as we are constrained to construct an equality proof that is not
computationally relevant.

Another worthy comparison to make is with \Lean{}, which has a $\kw{Prop}$ sort.
Terms of this sort are not autorised to be used in a proof relevant manner. Its
version of propositional extensionality has the following form:

\begin{minted}[escapeinside=@@,mathescape=true]{lean}
axiom propext {a b : Prop} : (a @$\leftrightarrow$@ b) @$\rightarrow$@ a = b
\end{minted}

This is similar to what we have in Typer, except that proof irrelevance is
enforced in a different manner.

\section{Equivalence relation}

First, we state what we mean when we say \emph{relation} to set the stage for
the subsequent discussion. For our purposes, we consider binary relations, which
are type formers that take two arguments of some type $\kw{A}$. Assuming that we
call the relation $\kw{R}$ and its two arguments $\id{a}$ and $\id{a}'$
respectively, inhabitants of the type $\Funapp{\kw{R}}{\id{a}}{\id{a}'}$ are
witnesses of this binary relation. The type signature of a binary relation has
the below form:

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
R : (A : Type) |$\Rrightarrow$| (a : A) |$\rightarrow$| (a' : A) |$\rightarrow$| Type
\end{minted}

For a quotient to be effective, its underlying relation has to be an equivalence relation, we shall use this property in the proof in the subsequent section. Recall that an equivalence relation implies that the relation is reflexive, symmetric and transitive. For it to be reflexive, it needs to be the case that given an arbitrary $\oftype{\id{a}}{\kw{A}}$, $\Funapp{\kw{R}}{\id{a}}{\id{a}}$ must be trivially inhabited. The symmetry of the relation implies that if we are given an arbitrary witness of $\Funapp{\kw{R}}{\id{a}}{\id{a}'}$, we need to be able to transform that into an inhabitant of $\Funapp{\kw{R}}{\id{a}'}{\id{a}}$. The relation is transitive if we are able to transform witnesses of $\Funapp{\kw{R}}{\id{a}}{\id{b}}$ and $\Funapp{\kw{R}}{\id{b}}{\id{c}}$ into witnesses of $\Funapp{\kw{R}}{\id{a}}{\id{c}}$\footnote{The equality type fulfills these criteria and is an equivalence relation.}.

In the built-in library, we define the following type as a witness that a certain relation is indeed an equivalence relation.

\begin{minted}{haskell}
type isEquivRel (A : Type) (R : A -> A -> Type) : Type
  | equivRel (isRefl : (a : A) -> R a a)
             (isSym : (a : A) -> (b : A) -> R a b -> R b a)
             (isTrans : (a : A) -> (b : A) -> (c : A)
                         -> R a b -> R b c -> R a c)
\end{minted}

\section{Proof}
Given two arbitrary elements $\id{a}$ and $\id{a}'$ of a base type $\kw{A}$, a
quotient is said to be effective if given a proof that the surjection of $\id{a}$
and $\id{a}'$ into the quotient are equal, then it must be the case that
$\Funapp{\kw{R}}{\id{a}}{\id{a}'}$ is true, i.e.\ we are able to find an
inhabitant of it. A sufficient condition for a quotient to be effective is that
the underlying relation must be both a proposition and an equivalence relation.

For an arbitrary binary relation $\kw{R}$, we can define the following:

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
ErasedR : (A : Type) |$\Rrightarrow$| (A |$\rightarrow$| A |$\rightarrow$| Type) |$\rightarrow$| A |$\rightarrow$| A |$\rightarrow$| Type
ErasedR R a b = Erased (R a b)
\end{minted}

Now, we state the proof of the effectiveness of quotients in the form of Typer code

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
effective : (A : Type) |$\Rrightarrow$| (R : A |$\rightarrow$| A |$\rightarrow$| Type)
            |$\rightarrow$| isEquivRel A (ErasedR R) |$\rightarrow$| (a : A) |$\rightarrow$| (b : A)
            |$\rightarrow$| Eq (Quotient_in (R := ErasedR R) a)
                  (Quotient_in (R := ErasedR R) b)
            |$\rightarrow$| ErasedR R a b
effective = lambda A |$\Rrightarrow$| lambda R equiv a b eq |$\rightarrow$|
  let
    helper : Quotient A (ErasedR R) -> Type
    helper x =
      Quotient_rec
        (R := ErasedR R)
        (lambda c |$\rightarrow$| ErasedR R a c)
        (p := lambda c d cd |$\rightarrow$|
          let
            ac->ad : Erased (R a c) |$\rightarrow$| Erased (R a d)
            ac->ad ac = equiv.isTrans a c d ac cd
            ad->ac : Erased (R a d) |$\rightarrow$| Erased (R a c)
            ad->ac ad = equiv.isTrans a d c ad
                                      (equiv.isSym c d cd)
          in
            propExt ac->ad ad->ac)
        x
    aa=ab : Eq (Erased (R a a)) (Erased (R a b))
    aa=ab = Eq_cong helper eq
  in
    Eq_cast (p := aa=ab) (f := id) (equiv.isRefl a)
\end{minted}

Compared to the more general version of the theorem we state before, here we insist that the quotient we consider be based on the erased version of some binary relation $\kw{R}$. And instead of proving that the base relation itself holds for some $\id{a}$ and $\id{b}$, we can only show that the erased version of this relation holds.

In this proof, we can see that all aspects of the sufficient condition are at
play. It is mainly used to prove that for arbitrary terms $\id{a}$, $\id{b}$ and
$\id{c}$ of type $\kw{A}$, if it is the case that if
$\Funapp{\id{Erased}}{(\Funapp{\kw{R}}{\id{b}}{\id{c}})}$ is inhabited, then
$\Funapp{\id{Erased}}{(\Funapp{\kw{R}}{\id{a}}{\id{b}})}$ $\iff$
$\Funapp{\id{Erased}}{(\Funapp{\kw{R}}{\id{a}}{\id{c}})}$. Intuitively speaking
this makes a lot of sense,
$\Funapp{\id{Erased}}{(\Funapp{\kw{R}}{\id{b}}{\id{c}})}$ implies that $\id{b}$
and $\id{c}$ are in the same equivalence class of the quotient. Hence, if we
know that $\id{a}$ is in the same equivalence class as $\id{b}$, we should
naturally be able to infer that $\id{a}$ and $\id{c}$ are also in the same
equivalence class, and vice versa. Propositional extensionality takes us even
further, by allowing us to prove that
$\Funapp{\id{Erased}}{(\Funapp{\kw{R}}{\id{a}}{\id{b}})}$ and
$\Funapp{\id{Erased}}{(\Funapp{\kw{R}}{\id{a}}{\id{c}})}$ are equal since they
are both mere propositions.

\chapter{Quotient Examples}\label{ch:quot-examples}
The addition of quotient types to Typer allows us to define certain constructs
that are typically defined in set theory as quotient sets. In this chapter, we
discuss some types that are now natively definable by taking the quotient of
existing types in the system.

\section{Rational numbers}
To define the rational numbers as a quotient type, we have two obvious options for the base type.

The first option is as follows:

\begin{align*}
  & \mathbb{Q} \ \coloneqq \mathbb{Z} \times \mathbb{N} / \sim_{\mathbb{Q}} \\
  & (z_1 , n_1) \sim_{\mathbb{Q}} (z_2 , n_2) \ \coloneqq Eq \ (z_1 * (n_2 + 1)) \ (z_2 * (n_1 + 1))
\end{align*}

A pair $(z , n)$ represents the rational number $z / (n + 1)$, this trick allows us to ensure that the denominator is non-zero.

The second option is similar to the first:

\begin{align*}
  & \mathbb{Q} \ \coloneqq \Sigma_{\oftype{(x, y)}{\mathbb{Z} \times \mathbb{Z}}} . y \ne 0 / \sim_{\mathbb{Q}} \\
  & (x_1 , y_1, \_) \sim_{\mathbb{Q}} (x_2 , y_2, \_) \ \coloneqq Eq \ (x_1 * y_2) \ (y_1 * x_2)
\end{align*}

In this definition, the base type of a quotient is a pair of integers, along
with a proof that the denominator is non-zero. We chose to use this as the basis
of our definition of the rationals, as it is more convenient to work with a pair
of elements of the same type.

Given that the equivalence of rational numbers is captured by a relation, we do
not need to normalise our rational numbers before or after each computation,
instead we prove that all of our operations respect the equivalence of rational
numbers. We hoped that this would give us better runtime efficiency, as opposed
to more naive implementations. To make this clearer, we illustrate one possible
naive implementation. To ensure that operations on the base type of the quotient
type that we intend to use to represent the rational numbers respect the
equivalence relation, we may be tempted to simply normalise the operands before
actually carrying out any computation. This implies that if the operands were
indeed equivalent, then the normalisation of the operands would have yielded two
provably equal terms. Hence by the congruence property of equality, the
operation would necessarily respect the underlying relation. However, it is
clear that such an approach might be expensive. To normalise the base type,
which we could imagine to be a pair of integers, we would have to divide both
integers by their greatest common divisor (GCD). The calculation of their GCD
could in itself be more costly than the actual operation itself. Thus, this
unnecessary normalisation could potentially adversely affect the runtime
efficiency of our operations on rational numbers. Hence, our definitions of
operations on the rational numbers do not rely on normalisation. However, this
is not without its downsides as it entails heavier proof obligations, this is a
topic that we shall discuss subsequently.

Typer has a built-in $\kw{Integer}$ type. Behind the scenes, this is based on
big integers in OCaml, leveraging the Zarith library. Operations on the typer
$\kw{Integer}$ type such as addition, multiplication, etc are implemented as
axioms. At runtime, the responsibilities of these functions are simply delegated
to their corresponding OCaml functions to carry out the necessary computations.
So far, we are unable to reason about these operations in Typer as they are
merely primitives that are implemented in the host language. In the following
section, we propose the addition of several axioms that serve as witnesses of
certain properties of the built-in $\kw{Integer}$ type, this will be crucial
when we start reasoning about operations on rational numbers.

\subsection*{Integer axioms}
We start off by axiomatising the associativity and commutativity of the addition and multiplication operations.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_+-comm : (x : Integer) |$\rightarrow$| (y : Integer)
                 |$\rightarrow$| Eq (Integer_+ x y) (Integer_+ y x)

Integer_+-assoc : (x : Integer) |$\rightarrow$| (y : Integer) |$\rightarrow$| (z : Integer)
                  |$\rightarrow$| Eq (Integer_+ x (Integer_+ y z))
                        (Integer_+ (Integer_+ x y) z)

Integer_*-comm : (x : Integer) |$\rightarrow$| (y : Integer)
                 |$\rightarrow$| Eq (Integer_* x y) (Integer_* y x)

Integer_*-assoc : (x : Integer) |$\rightarrow$| (y : Integer) |$\rightarrow$| (z : Integer)
                  |$\rightarrow$| Eq (Integer_* x (Integer_* y z))
                        (Integer_* (Integer_* x y) z)
\end{minted}

We also want to be able to show that multiplication is distributive with respect
to addition. We only add left distributivity as an axiom, as right
distributivity can be easily proven as a theorem, this is also the case for the
other axioms that we will describe below.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_*DistL+ : (x : Integer) |$\rightarrow$| (y : Integer) |$\rightarrow$| (z : Integer)
                  |$\rightarrow$| Eq (Integer_* (Integer_+ x y) z)
                        (Integer_+ (Integer_* x z) (Integer_* y z))
\end{minted}

The above properties can also be stated for the subtraction operation. We also
want to be able to say that we have additive inverses for all integers and that
0 is the additive identity.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_+Linv : (x : Integer) |$\rightarrow$| Eq (Integer_+ (Integer_- 0 x) x) 0

Integer_+Lid : (x : Integer) |$\rightarrow$| Eq (Integer_+ 0 x) x
\end{minted}

Of course, we should also be able to say that 1 is the multiplicative identity.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_*Lid : (x : Integer) |$\rightarrow$| Eq (Integer_* 1 x) x
\end{minted}

Now that we have all these axioms, we can say that $\kw{Integer}$ fulfills the
properties of a commutative ring. Aside from these axioms, there are some other
properties that we require in order to be able to construct some useful
operations on the resulting $\kw{Rational}$ type. Notably, we need to be able to
say that if the product of two integers is zero, then at least one of them is
zero. We formulate this in the following manner:

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_isIntegral : (x : Integer) |$\rightarrow$| (y : Integer)
                     |$\rightarrow$| Eq (Integer_* x y) 0 |$\rightarrow$| (Eq x 0 |$\rightarrow$| Void)
                     |$\rightarrow$| Eq y 0
\end{minted}

Here, $\kw{Void}$ is the $\mathbb{0}$ type (also known as the empty type or
bottom). This axiom essentially states that if a product $x \cdot y = 0$, then
$x \ne 0 \rightarrow y = 0$.

Another useful axiom to have is one that asserts that 0 is an absorbing element
with respect to multiplication. In other words, multiplying by 0 always yields 0
as a result.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_*Lzero : (x : Integer) |$\rightarrow$| Eq (Integer_* 0 x) 0
\end{minted}

\subsection*{Integer theorems}\label{subsection:int-theorems}
As stated in the subsequent section, we only added the `left' version of some
axioms, as their `right' counterparts may be trivially proven as theorems based
on the commutativity property of addition and multiplication.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_+Rid : (x : Integer) |$\rightarrow$| Eq (Integer_+ x 0) x
Integer_+Rid x = Eq_trans (Integer_+-comm x 0) (Integer_+Lid x)

Integer_+Rinv : (x : Integer) |$\rightarrow$| Eq (Integer_+ x (Integer_- 0 x)) 0
Integer_+Rinv x = Eq_trans (Integer_+-comm x (Integer_- 0 x))
                           (Integer_+Linv x)

Integer_*Rid : (x : Integer) |$\rightarrow$| Eq (Integer_* x 1) x
Integer_*Rid x = Eq_trans (Integer_*-comm x 1) (Integer_*Lid x)

Integer_*Rzero : (x : Integer) |$\rightarrow$| Eq (Integer_* x 0) 0
Integer_*Rzero x = Eq_trans (Integer_*-comm x 0) (Integer_*Lzero x)

Integer_*DistR+ : (x : Integer) |$\rightarrow$| (y : Integer) |$\rightarrow$| (z : Integer)
                  |$\rightarrow$| Eq (Integer_* x (Integer_+ y z))
                        (Integer_+ (Integer_* x y) (Integer_* x z))
Integer_*DistR+ x y z =
  Eq_trans (Integer_*-comm x (Integer_+ y z))
           (Eq_trans (Integer_*DistL+ y z x)
                     (Eq_trans (Eq_cong (lambda e |$\rightarrow$|
                                           Integer_+ e (Integer_* z x))
                                        (Integer_*-comm y x))
                               (Eq_cong (lambda e |$\rightarrow$|
                                           Integer_+ (Integer_* x y) e)
                                        (Integer_*-comm z x))))
\end{minted}

Another useful theorem that we can prove states that the product of two non-zero integers is necessarily non-zero.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_0-product : (x : Integer) |$\rightarrow$| (y : Integer)
                    |$\rightarrow$| (Eq x 0 |$\rightarrow$| Void) |$\rightarrow$| (Eq y 0 |$\rightarrow$| Void)
                    |$\rightarrow$| (Eq (Integer_* x y) 0 |$\rightarrow$| Void)
Integer_0-product x y x|$\ne$|0 y|$\ne$|0 xy|$\ne$|0 =
    y|$\ne$|0 (Integer_isIntegral x y xy|$\ne$|0 x|$\ne$|0)
\end{minted}

We will eventually also make use of the below theorem that states that the negation of an integer may be distributed over multiplication. Its `right' counterpart may also be proven in a similar manner.

\begin{minted}[escapeinside=||,mathescape=true]{haskell}
Integer_NegateDistL* : (x : Integer) |$\rightarrow$| (y : Integer)
                        |$\rightarrow$| Eq (Integer_- 0 (Integer_* x y))
                              (Integer_* (Integer_- 0 x) y)
Integer_NegateDistL* x y =
  Integer_- 0 (Integer_* x y)
  ==< Eq_cong (lambda e |$\rightarrow$| Integer_- e (Integer_* x y))
              (Eq_comm (Integer_*Lzero y)) >==
  Integer_- (Integer_* 0 y) (Integer_* x y)
  ==< Eq_comm (Integer_*DistL- 0 x y) >==
  Integer_* (Integer_- 0 x) y |$\qed$|
\end{minted}

\subsection*{Implementation of Rationals}
As stated before, the base type of our quotient type is essentially a pair of integers along with a proof that the second integer is non-zero. We decided to implement this as an inductive type with a single constructor.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
type @$\mathbb{Z}{\times}\mathbb{Z}{\ne}0$@
  | inR (@$z_1$@ : Integer) (@$z_2$@ : Integer) (p : Not (Eq @$z_2$@ 0))
\end{minted}

$\kw{Not}$ has the typical definition as follows:
\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Not : (T : Type) @$\rightarrow$@ Type
Not T = T @$\rightarrow$@ Void
\end{minted}

The underlying relation takes on the following form, this may be proven to be
both an equivalence relation as well as a mere proposition. These properties are
useful if we wish to prove that resulting quotient is effective and that
\id{Rational} is discrete.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
equal@$\mathbb{Q}$@ : @$\zpair$@ @$\rightarrow$@ @$\zpair$@ @$\rightarrow$@ Type
equal@$\mathbb{Q}$@ p1 p2 = Eq (p1.z1 * p2.z2) (p1.z2 * p2.z1)
\end{minted}

Finally, we can state the definition of the Rationals.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Rational : Type
Rational = Quotient @$\zpair$@ equal@$\mathbb{Q}$@
\end{minted}

Negation is the simplest operation that we can define on the rationals, it is
achieved by simply negating the integer numerator. This is done via the below
function.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
negate_fst : @$\zpair \rightarrow \zpair$@
negate_fst x = inR (-1 * x.z1) x.z2 x.p
\end{minted}

We also need to prove that $\id{negate\_fst}$ respects the underlying relation
$equal\mathbb{Q}$. In other words, we need to prove the following:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
negate_compat : (a : @$\zpair$@) @$\rightarrow$@ (b : @$\zpair$@) @$\rightarrow$@
                @$\equalq$@ a b @$\rightarrow$@ @$\equalq$@ (negate_fst a) (negate_fst b)
negate_compat a b r =
    (-1 * a.z1) * b.z2
    ==< Eq_comm (Integer_*-assoc -1 a.z1 b.z2) >==
    -1 * (a.z1 * b.z2)
    ==< Eq_cong (lambda e @$\rightarrow$@ -1 * e) r >==
    -1 * (a.z2 * b.z1)
    ==< Integer_*-assoc -1 a.z2 b.z1 >==
    (-1 * a.z2) * b.z1
    ==< Eq_cong (lambda e @$\rightarrow$@ e * b.z1)
                (Integer_*-comm -1 a.z2) >==
    (a.z2 * -1) * b.z1
    ==< Eq_comm (Integer_*-assoc a.z2 -1 b.z1) >==
    a.z2 * (-1 * b.z1) @$\qed$@
\end{minted}

We introduced equational reasoning to facilitate the development and reading of
such proofs, more details are given in Section~\ref{section:eqreasoning} of the
appendix.

Finally, the negation operation of rational numbers may be constructed like so:

\begin{minted}[escapeinside=@@,mathescape=true,samepage]{haskell}
Rational_negate : Rational @$\rightarrow$@ Rational
Rational_negate x =
  qcase (x : @$\zpair$@ / @$\equalq$@)
    | Quotient_in a @$\Rightarrow$@ Quotient_in (R := @$\equalq$@) (negate_fst a)
    | Quotient_eq a a' r @$\Rightarrow$@ Quotient_eq (R := @$\equalq$@)
                                        (a := negate_fst a)
                                        (a' := negate_fst a')
                                        (negate_compat a a' r)
\end{minted}

We can also define the addition operation on the rationals. As before, we start
off by defining a function that operates on expressions of the base type.

\begin{minted}[escapeinside=@@,mathescape=true,samepage]{haskell}
@$\zpairplus$@ : @$\zpair$@ @$\rightarrow$@ @$\zpair$@ @$\rightarrow$@ @$\zpair$@
@$\zpairplus$@ a b = inR ((a.z1 * b.z2) + (b.z1 * a.z2))
                 (a.z2 * b.z2)
                 (Integer_0-product a.z2 b.z2 a.p b.p)
\end{minted}

This is an operation that can be shown to be commutative with respect to the
relation.

\begin{minted}[escapeinside=@@,mathescape=true,samepage]{haskell}
@$\zpairplus$-Comm@ : (a : @$\zpair$@) @$\rightarrow$@ (b : @$\zpair$@)
               @$\rightarrow$@ Eq (t := Quotient @$\zpair$@ @$\equalq$@)
                     (Quotient_in (@$\zpairplus$@+ a b)) (Quotient_in (@$\zpairplus$@+ b a))
@$\zpairplus$-Comm@ a b =
  let
    compat =
      (a.z1 * b.z2 + b.z1 * a.z2) * (b.z2 * a.z2)
        ==< Eq_cong (lambda e @$\rightarrow$@ (a.z1 * b.z2 + b.z1 * a.z2) * e)
                    (Integer_*-comm b.z2 a.z2) >==
      (a.z1 * b.z2 + b.z1 * a.z2) * (a.z2 * b.z2)
        ==< Integer_*-comm (a.z1 * b.z2 + b.z1 * a.z2) (a.z2 * b.z2) >==
      a.z2 * b.z2 * (a.z1 * b.z2 + b.z1 * a.z2)
        ==< Eq_cong (lambda e @$\rightarrow$@ a.z2 * b.z2 * e)
                    (Integer_+-comm (a.z1 * b.z2) (b.z1 * a.z2)) >==
      a.z2 * b.z2 * (b.z1 * a.z2 + a.z1 * b.z2) @$\qed$@
  in
      Quotient_eq (R := @$\equalq$@)
                  (a  := @$\zpairplus$@+ a b)
                  (a' := @$\zpairplus$@+ b a)
                  compat
\end{minted}

We still need to show that the $\zpairplus$ function itself respects the
underlying relation, and since this is a binary operation, we will have to prove
it for `both sides'. In other words, we have to produce the below proofs.

\begin{minted}[escapeinside=@@,mathescape=true,samepage]{haskell}
@$\mathbb{Q}$+\_feql@ : (a : @$\zpair$@) @$\rightarrow$@ (a' : @$\zpair$@) @$\rightarrow$@ (b : @$\zpair$@) @$\rightarrow$@ @$\equalq$@ a a'
          @$\rightarrow$@ Eq (t := Quotient @$\zpair$@ @$\equalq$@)
                (Quotient_in (@$\zpairplus$@ a b))
                (Quotient_in (@$\zpairplus$@ a' b))
@$\mathbb{Q}$+\_feql@ = ?

@$\mathbb{Q}$+\_feqr@ : (a : @$\zpair$@) @$\rightarrow$@ (b : @$\zpair$@) @$\rightarrow$@ (b' : @$\zpair$@) @$\rightarrow$@ @$\equalq$@ b b'
          @$\rightarrow$@ Eq (t := Quotient @$\zpair$@ @$\equalq$@)
                (Quotient_in (@$\zpairplus$@ a b))
                (Quotient_in (@$\zpairplus$@ a b'))
@$\mathbb{Q}$+\_feqr@ = ?
\end{minted}

The proof of $\mathbb{Q}{+}\_\kw{feql}$ is long and uninteresting and thus will
not described here\footnote{Interested readers may find the proof at TODO:\ link
to online repository since the proof itself is not instructive enought to
warrant being put here}. However, once this has been proved, its counterpart is
a trivial corollary by virtue of the commutativity of $\zpairplus$.

\begin{minted}[escapeinside=@@,mathescape=true,samepage]{haskell}
@$\mathbb{Q}$+\_feqr@ a b b' p =
    Eq_trans (@$\zpairplus$-Comm@ a b)
             (Eq_trans (@$\mathbb{Q}$@+_feql b b' a p) (@$\zpairplus$-Comm@ b' a))
\end{minted}

We can now assemble the above to define both the addition and subtraction of
rationals as follows:

\begin{minted}[escapeinside=@@,mathescape=true,samepage]{haskell}
Rational_+ : Rational @$\rightarrow$@ Rational @$\rightarrow$@ Rational
Rational_+ a b =
  Quotient_rec2 (R := @$\equalq$@) (S := @$\equalq$@)
                Rational_isSet (lambda x y @$\rightarrow$@ Quotient_in (@$\zpairplus$@ x y))
                @$\mathbb{Q}$+\_feql@ @$\mathbb{Q}$+\_feqr@ a b

Rational_- : Rational @$\rightarrow$@ Rational @$\rightarrow$@ Rational
Rational_- a b = Rational_+ a (Rational_negate b)
\end{minted}

$\id{Quotient\_rec2}$ is a library function that allows us to simultaneously
eliminate two quotient expressions, more details are given in
\autoref{subsec:rec2}. Finally, we want to prove that the negation of a rational
produces its additive inverse. We define $\id{Rational\_0}$ to be the additive
identity using a trivial representative of its equivalence class.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
@$\zpairplus$@-Linv : (a : @$\zpair$@) @$\rightarrow$@ Eq (t := Rational)
                              (Quotient_in (@$\zpairplus$@ (negate_a.z1) a))
                              Rational_0
@$\zpairplus$@-Linv a =
  let
    h : Eq ((-1 * a.z1 * a.z2 + a.z1 * a.z2) * 1)
           (a.z2 * a.z2 * 0)
    h =
      (-1 * a.z1 * a.z2 + a.z1 * a.z2) * 1
      ==< Eq_cong (lambda e @$\rightarrow$@ (e * a.z2 + a.z1 * a.z2) * 1)
                  (Integer_Negate@$\equiv$@ a.z1) >==
      ((0 - a.z1) * a.z2 + a.z1 * a.z2) * 1
      ==< Integer_*Rid ((0 - a.z1) * a.z2 + a.z1 * a.z2) >==
      (0 - a.z1) * a.z2 + a.z1 * a.z2
      ==< Eq_cong (lambda e @$\rightarrow$@ e + a.z1 * a.z2)
                  (Eq_comm (Integer_NegateDistL* a.z1 a.z2)) >==
      (0 - (a.z1 * a.z2)) + a.z1 * a.z2
      ==< Integer_+-comm (0 - (a.z1 * a.z2)) (a.z1 * a.z2) >==
      a.z1 * a.z2 + (0 - (a.z1 * a.z2))
      ==< Integer_+Rinv (a.z1 * a.z2) >==
      0
      ==< Eq_comm (Integer_*Rzero (a.z2 * a.z2)) >==
      a.z2 * a.z2 * 0 @$\qed$@
  in
    Quotient_eq (R := @$\equalq$@)
                (a := @$\zpairplus$@ (negate_a.z1) a)
                (a' := inR 0 1 Integer_1@$\ne$@0)
                h

Rational_+Linv : (q : Rational) @$\rightarrow$@ Eq (Rational_+ (Rational_negate q) q)
                                      Rational_0
Rational_+Linv q =
  Quotient_elimProp (R := @$\equalq$@)
                    (P := lambda q @$\rightarrow$@
                            Eq (Rational_+ (Rational_negate q) q)
                               Rational_0)
                    (lambda q @$\rightarrow$@
                        Rational_isSet (Rational_+ (Rational_negate q) q)
                                       Rational_0)
                    @$\zpairplus$@-Linv q

Rational_+Rinv : (q : Rational) @$\rightarrow$@ Eq (Rational_+ q (Rational_negate q))
                                      Rational_0
Rational_+Rinv q = Eq_trans (Rational_+-Comm q (Rational_negate q))
                            (Rational_+Linv q)

\end{minted}

For brevity, we do not describe the proofs for multiplication as they can be
carried out in a similar fashion as above. As a sanity check of the validity of
our construction of the rational numbers, we provided proofs of other
interesting properties of \id{Rational} in the actual file, proving that it does
indeed satisfy the characteristics of a \emph{ring}.

\section{Multiset}\label{sec:multiset}

A multiset is an abstract data type that may be seen as a generalisation of
sets. In sets, multiple occurrences of the `same' item are ignored, whereas
multisets keep track of repeated occurrences of items. One way of defining such
a data type (albeit not a very efficient one) is by taking a quotient of the
list data type with an equivalence relation such that all permutations of a
given list are equivalent.

To that end, we wish to define a relation $\fn{ListPerm $l_1$ $l_2$}$ such that
$\fn{$l_1$}$ and $\fn{$l_2$}$ are permutations of each other. The relation would
thus need a constructor of the following form:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
swapPerm : (x : A) @$\rightarrow$@ (y : A) @$\rightarrow$@ (l : List A)
           @$\rightarrow$@ ListPerm ?A (cons (y (cons x l))) (cons x (cons y l))
\end{minted}

The relation is symmetric as it is, however, for it to be an equivalence
relation, we also require the relation to be reflexive and transitive. We thus
need to complement it with additional constructors, this is analogous to
constructing the reflexive and transitive closure of a relation.

For the relation to be reflexive, we would require the following constructors
such that $\fn{ListPerm}$ is closed under the base constructors of the List
datatype.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
nilPerm : ListPerm ?A nil nil

consPerm : (x : ?A) @$\rightarrow$@ (l1 : List ?A) @$\rightarrow$@ (l2 : List ?A)
           @$\rightarrow$@ (ListPerm ?A l1 l2) @$\rightarrow$@ (ListPerm ?A (cons x l1) (cons x l2))
\end{minted}

Finally, the following addition makes the relation transitive:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
transPerm : (l1 : List ?A) @$\rightarrow$@ (l2 : List ?A) @$\rightarrow$@ (l3 : List ?A)
            @$\rightarrow$@ (ListPerm ?A l1 l2) @$\rightarrow$@ (ListPerm ?A l2 l3)
            @$\rightarrow$@ (ListPerm ?A l1 l3)
\end{minted}

The manner in which the $\fn{ListPerm}$ relation has been presented so far suggests
that it would most appropriately be defined as a GADT. Typer does not have built-in
support for GADTs, however, we draw inspiration from\cite{sulzmann2007systemfeq} to
encode such a GADT as an inductive type with explicit equality proofs.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
ListPerm : (A : Type_ ?) @$\rightarrow$@ List A @$\rightarrow$@ List A @$\rightarrow$@ Type_ ?
type ListPerm (l ::: TypeLevel) (A : Type_ l) (l1 : List A) (l2 : List A) : Type_ l
  | nilPerm (p1 :: Eq l1 nil) (p2 :: Eq l2 nil)
  | consPerm (x : A) (l1' : List A) (l2' : List A) (ListPerm A l1' l2')
             (p1 :: Eq l1 (cons x l1')) (p2 :: Eq l2 (cons x l2'))
  | swapPerm (x : A) (y : A) (l : List A)
             (p1 :: Eq l1 (cons x (cons y l)))
             (p2 :: Eq l2 (cons y (cons x l)))
  | transPerm (l1' : List A) (l2' : List A) (l3' : List A)
              (ListPerm A l1' l2') (ListPerm A l2' l3')
              (p1 :: Eq l1 l1') (p2 :: Eq l2 l3')
\end{minted}

With that, we may now define the $\fn{Multiset}$ type former.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Multiset : Type_ ? @$\rightarrow$@ Type_ ?
Multiset A = Quotient (List A) (ListPerm A)
\end{minted}

An empty multiset is simply the canonical surjection of the $\fn{nil}$ List into
the Quotient.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Multiset_empty : Multiset ?A
Multiset_empty = Quotient_in nil
\end{minted}

Insertion is merely the application of the $\fn{cons}$ constructor of List with the help
of $\fn{consPerm}$ that we previously defined.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Multiset_cons : ?A @$\rightarrow$@ Multiset ?A @$\rightarrow$@ Multiset ?A
Multiset_cons = lambda _ A @$\Rrightarrow$@ lambda a s @$\rightarrow$@
  qcase (s : List A / ListPerm A)
    | Quotient_in l @$\Rightarrow$@ Quotient_in (R := ListPerm A) (cons a l)
    | Quotient_eq l l' r @$\Rightarrow$@ Quotient_eq (R := ListPerm A)
                                        (a := cons a l)
                                        (a' := cons a l')
                                        (consPerm a l l' r (_ := Eq_refl)
                                                           (_ := Eq_refl))
\end{minted}

Other useful operations on the Multiset datatype may be defined, such as
$\fn{Multiset\_append}$, $\fn{Multiset\_length}$, $\fn{Multiset\_mem}$ etc. The
first two may be defined in a routine manner, hence we briefly describe the
definition $\fn{Multiset\_mem}$ as it is more interesting. This function
determines if a certain term of type $\fn{A}$ is a member of a multiset. Its
type is as follows:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Multiset_mem : (A : Type) @$\Rrightarrow$@ Discrete A @$\rightarrow$@ A @$\rightarrow$@ Multiset A @$\rightarrow$@ Bool
\end{minted}

In order for this function to work, the underlying type $\fn{A}$ must be
discrete, i.e.\ the equality between two terms of this type must be decidable.
We define $\fn{Any}$ to be a witness that a certain predicate is valid for some
element in a given list. We then define a predicate $\fn{isMember}$ such that
$\fn{isMember a l}$ means that $\fn{a}$ is a member of the list $\fn{l}$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Any : (A : Type) -> (P : (a : A) -> Type) -> List A -> Type
type Any (A : Type) (P : ((a : A) -> Type)) (l : List A) : Type
  | here (x : A) (xs : List A) (p ::: P x) (eq ::: Eq l (cons x xs))
  | there (x : A) (xs : List A) (@$\neg$@p ::: Not (P x)) (Any A P xs)
          (eq ::: Eq l (cons x xs))

isMember : (A : Type) => A -> List A -> Type
isMember = lambda A => lambda x l -> Any A (lambda x' -> Eq x x') l
\end{minted}

%% The omitted proofs are uninteresting so far as quotient types are concerned
We need to prove a lemma that says that if $\fn{isMember a $l_1$}$ is valid,
then for some other $\fn{$l_2$}$ that is a permutation of $\fn{$l_1$}$,
$\fn{isMember a $l_2$}$ is also valid, we omit this proof. Next, we just need to
define $\fn{isMemberDec}$, whose details we shall once again omit. Finally, we
may proceed to define $\fn{Multiset\_mem}$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
isMemberDec : (A : Type) @$\Rightarrow$@ Discrete A @$\rightarrow$@ (a : A) @$\rightarrow$@ (l : List A)
              @$\rightarrow$@ Decidable (isMember a l)
isMemberDec = ...

Multiset_mem : (A : Type) @$\Rightarrow$@ Discrete A @$\rightarrow$@ A @$\rightarrow$@ Multiset A @$\rightarrow$@ Bool;
Multiset_mem disc a s =
  let
    Dec2Bool : Decidable ?A @$\rightarrow$@ Bool
    Dec2Bool d = case d
      | yes => true
      | no => false

    compat : (l1 : List A) @$\rightarrow$@ (l2 : List A) @$\rightarrow$@ ListPerm A l1 l2
             @$\rightarrow$@ Eq (Dec2Bool (isMemberDec disc a l1))
                   (Dec2Bool (isMemberDec disc a l2))
    compat l1 l2 r = ...
  in
    qcase (x : List A / ListPerm A)
        | Quotient_in l @$\Rightarrow$@ Dec2Bool (isMemberDec disc a l)
        | Quotient_eq a a' r @$\Rightarrow$@ compat a a' r
\end{minted}

Although this has not be done in this work, another operation that one may find
useful to have is one that counts how many elements of the multiset are equal to
a certain term of type $\fn{A}$.

\section{Propositional Truncation}

We can encode propositional truncation as a quotient type. The required properties are:

\begin{itemize}
	\item $\id{A} \ \kw{true} \rightarrow \norm{A} \ \kw{true}$ and $\norm{A}$
      is a subsingleton (exists unique)
%% 	\item $\id{A}  \ $subsingleton$ \rightarrow (\norm{A} \ \kw{true} \rightarrow \id{A} \ \kw{true})$
	\item For some P that is a subsingleton and some $f : \id{A} \rightarrow \kw{P}$, there exists a function $g : \norm{A} \rightarrow P$ s.t. $ \forall a : A \ . \ g(a^*) = f(a)$, where $a^* \in \norm{A}$.
\end{itemize}

The encoding is simple, we simply define the following type former along with its term former:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
PropTrunc : (P : Type) @$\rightarrow$@ Type
PropTrunc P = Quotient P (@$\lambda$@ p1 p2 @$\rightarrow$@ Unit)

inPropTrunc : (P : Type) @$\Rrightarrow$@ P @$\rightarrow$@ PropTrunc P
inPropTrunc p = Quotient_in (R := @$\lambda$@ p1 p2 @$\rightarrow$@ Unit) p
\end{minted}

The choice of $\id{R}$ here essentially implies that every term of the base type $\kw{P}$ shall be equated in the resulting quotient type. This is witnessed by the following function:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
squash : (P : Type) @$\Rrightarrow$@ (x : PropTrunc P) @$\rightarrow$@ (y : PropTrunc P) @$\rightarrow$@ Eq x y
squash = @$\lambda$@ P @$\Rrightarrow$@ @$\lambda$@ x y @$\rightarrow$@
  let
    rel : P @$\rightarrow$@ P @$\rightarrow$@ Type
    rel _ _ = Unit
  in
    elimProp2 (R := rel) (S := rel)
              (P := @$\lambda$@ x y @$\rightarrow$@ Eq x y)
              (@$\lambda$@ x y @$\rightarrow$@ Quotient_trunc (R := rel) (x := x) (y := y))
              (@$\lambda$@ a a' @$\rightarrow$@ Quotient_eq (R := rel)
                                     (a := a) (a' := a') unit)
              x y
\end{minted}

$\id{inPropTrunc}$ and $\id{squash}$ combined imply that the first property is satisfied. Next, we state the elimination principle of the propositional truncation of some type $\id{P}$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
propTruncRec : (A P : Type) @$\Rrightarrow$@ isProp P @$\rightarrow$@ (A @$\rightarrow$@ P) @$\rightarrow$@ PropTrunc A @$\rightarrow$@ P
propTruncRec prop f a = elimProp (R := @$\lambda$@ _ _ @$\rightarrow$@ Unit)
                                 (P := @$\lambda$@ _ @$\rightarrow$@ P)
                                 (@$\lambda$@ _ @$\rightarrow$@ prop)
                                 f a
\end{minted}

By partially applying a proof that P is a proposition and a function of type
$\id{A} \rightarrow \id{P}$ to $\id{propTruncRec}$, we obtain the second
property.

\section{Normalised Types}

Nomalised types introduced in \autoref{sec:normalised-types-courtieu} are a
strict subset of our quotient types, we show how we encode them in our system.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Qnorm : (A : Type) @$\rightarrow$@ (nf : A @$\rightarrow$@ A) @$\rightarrow$@ Type
Qnorm A nf = Quotient A (@$\lambda$@ x y @$\rightarrow$@ Eq (nf x) (nf y))

Qnorm_in : ?A @$\rightarrow$@ Qnorm ?A ?nf
Qnorm_in a = Quotient_in a

Qnorm_elim : Qnorm ?A ?nf @$\rightarrow$@ (?A @$\rightarrow$@ ?B) @$\rightarrow$@ ?B
Qnorm_elim q f = Quotient_rec (f @$\circ$@ nf)
                              (p := @$\lambda$@ x y r @$\rightarrow$@ Eq_cong f r)
                              q

Qnorm_eq : (a a' : ?A) @$\rightarrow$@ Eq (nf a) (nf a') @$\rightarrow$@ Eq (Qnorm_in a) (Qnorm_in a')
Qnorm_eq a a' eq = Quotient_eq (a := a') (a' = a') eq
\end{minted}

The \id{Qnorm} type former is constructed as a quotient with a relation defined
by the equality of normalised terms. The construction of a term of type
\id{Qnorm A nf} is simply a surjection into the quotient. The elimination
principle simply applies the function \id{f} after normalising the term of the
base type. The user is not required to provide additional coherence proofs as we
immediately appeal to the congruence property of equality. We can also construct
\id{Qnorm\_eq}, a proof that terms that share the same normal form are
necessarily equal after their surjection into the quotient. We mention however
that this may only be proven propositionally, as opposed to Courtieu's system
where such an equality would hold judgementally.

\section{Elimination (Special cases)}

The elimination of quotients involves numerous proof obligations, and this
quickly gets tedious especially if we are eliminating multiple quotient
expressions at once. We provide a library that aims to reduce repetitive
boilerplate in user code.

\subsection*{rec2}\label{subsec:rec2}
We start off by describing \id{Quotient\_rec2}, which serves to eliminate two arbitrary quotient expressions.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
rec2 : (A B C: Type_ ?) @$\Rrightarrow$@
       (R : A @$\rightarrow$@ A @$\rightarrow$@ Type_ ?) @$\Rrightarrow$@
       (S : B @$\rightarrow$@ B @$\rightarrow$@ Type_ ?) @$\Rrightarrow$@
       (C_isSet : isSet C) @$\rightarrow$@
       (f : A @$\rightarrow$@ B @$\rightarrow$@ C) @$\rightarrow$@
       ((a : A) @$\rightarrow$@ (b : A) @$\rightarrow$@ (c : B) @$\rightarrow$@ R a b @$\rightarrow$@ Eq (f a c) (f b c)) @$\rightarrow$@
       ((a : A) @$\rightarrow$@ (b : B) @$\rightarrow$@ (c : B) @$\rightarrow$@ S b c @$\rightarrow$@ Eq (f a b) (f a c)) @$\rightarrow$@
       Quotient A R @$\rightarrow$@ Quotient B S @$\rightarrow$@ C
rec2 =
  @$\lambda$@ _ _ _ _ _ A B C R S @$\Rrightarrow$@
    @$\lambda$@ C_isSet f feql feqr @$\rightarrow$@
      Quotient_rec (R := R)
        (@$\lambda$@ a @$\rightarrow$@ @$\lambda$@ b @$\rightarrow$@
          Quotient_rec (R := S) (f a) (p := feqr a) b)
        (p := @$\lambda$@ a a' r @$\rightarrow$@
          let
            eqf : (b : B) @$\rightarrow$@ Eq (f a b) (f a' b)
            eqf b = feql a a' b r
            p : (x : Quotient B S) @$\rightarrow$@
                isProp (Eq (Quotient_rec (f a) (p := feqr a) x)
                           (Quotient_rec (f a') (p := feqr a') x))
            p x = C_isSet (Quotient_rec (f a) (p := feqr a) x)
                          (Quotient_rec (f a') (p := feqr a') x)
            compat : (x : Quotient B S) @$\rightarrow$@
                     (Eq (Quotient_rec (f a) (p := feqr a) x)
                         (Quotient_rec (f a') (p := feqr a') x))
            compat x = elimProp (R := S)
                                (P := @$\lambda$@ x @$\rightarrow$@
                                  (Eq (Quotient_rec (f a) (p := feqr a) x)
                                      (Quotient_rec (f a') (p := feqr a') x)))
                                p eqf x
          in
            Eq_funext (f := Quotient_rec (f a) (p := feqr a))
                      (g := Quotient_rec (f a') (p := feqr a'))
                      compat)
\end{minted}

The function itself does the only logical thing it could do, it uses \kw{Quotient\_rec} to eliminate the first quotient, and then it makes another nested call to \kw{Quotient\_rec} to eliminate the second one. Essentially, the result of the elimination of the first quotient is a function that takes another quotient as an argument and then eliminates that. This is the intution behind the requirement that the output type $\id{C}$ be a $\kw{Set}$. In other words, this enables us to prove that for two quotients of type $\id{Quotient A R}$, we are indeed producting two output functions that are equal. We also made use of $\id{elimProp}$, a function that we shall describe next.

\subsection*{elimProp}
$\id{elimProp}$ is a function that simplifies the elimination of a quotient when
the target type is a $\kw{Prop}$ as was introduced in
\autoref{subsec:mere-propositions}. We will see that the nature of the function
$\id{f}$ has no bearing on our proof obligations, as they can be discharged in a
very systematic way by leveraging the fact that output type is a $\kw{Prop}$.
First, we need to proof a lemma, $\id{toPathOver}$. Suppose that we have a type
former $\id{A} : \id{I} \Rrightarrow \kw{Type}$ and two terms $\id{x}$ and
$\id{y}$ of types $\Funapp{\id{A}}{(\earg{\_}{\ileft})}$ and
$\Funapp{\id{A}}{(\earg{\_}{\iright})}$ respectively, we get the following
diagram.


\begin{center}
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Ellipse [id:dp6858943436655307]
\draw  [fill={rgb, 255:red, 231; green, 234; blue, 244 }  ,fill opacity=1 ] (230,230.5) .. controls (230,202.61) and (269.18,180) .. (317.5,180) .. controls (365.82,180) and (405,202.61) .. (405,230.5) .. controls (405,258.39) and (365.82,281) .. (317.5,281) .. controls (269.18,281) and (230,258.39) .. (230,230.5) -- cycle ;
%Shape: Ellipse [id:dp4978096684614166]
\draw  [fill={rgb, 255:red, 255; green, 219; blue, 219 }  ,fill opacity=1 ] (230,103) .. controls (230,79.25) and (268.73,60) .. (316.5,60) .. controls (364.27,60) and (403,79.25) .. (403,103) .. controls (403,126.75) and (364.27,146) .. (316.5,146) .. controls (268.73,146) and (230,126.75) .. (230,103) -- cycle ;
%Shape: Circle [id:dp2462377080592002]
\draw  [fill={rgb, 255:red, 242; green, 5; blue, 5 }  ,fill opacity=1 ] (326,105.5) .. controls (326,103.01) and (328.01,101) .. (330.5,101) .. controls (332.99,101) and (335,103.01) .. (335,105.5) .. controls (335,107.99) and (332.99,110) .. (330.5,110) .. controls (328.01,110) and (326,107.99) .. (326,105.5) -- cycle ;
%Shape: Circle [id:dp1552015327211651]
\draw  [fill={rgb, 255:red, 26; green, 38; blue, 234 }  ,fill opacity=1 ] (360,244.5) .. controls (360,242.01) and (362.01,240) .. (364.5,240) .. controls (366.99,240) and (369,242.01) .. (369,244.5) .. controls (369,246.99) and (366.99,249) .. (364.5,249) .. controls (362.01,249) and (360,246.99) .. (360,244.5) -- cycle ;
%Shape: Circle [id:dp924511868212545]
\draw  [fill={rgb, 255:red, 26; green, 38; blue, 234 }  ,fill opacity=1 ] (271,244.5) .. controls (271,242.01) and (273.01,240) .. (275.5,240) .. controls (277.99,240) and (280,242.01) .. (280,244.5) .. controls (280,246.99) and (277.99,249) .. (275.5,249) .. controls (273.01,249) and (271,246.99) .. (271,244.5) -- cycle ;
%Straight Lines [id:da43777492366231496]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (280,244.5) -- (360,244.5) ;
%Straight Lines [id:da5251303335065973]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (330.5,105.5) -- (364.5,244.5) ;
%Straight Lines [id:da2553652396779533]
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (330.5,105.5) -- (275.5,244.5) ;

% Text Node
\draw (321,82) node [anchor=north west][inner sep=0.75pt]   [align=left] {x};
% Text Node
\draw (371,232) node [anchor=north west][inner sep=0.75pt]   [align=left] {y};
% Text Node
\draw (244,222) node [anchor=north west][inner sep=0.75pt]  [font=\scriptsize] [align=left] {transport\_x};
% Text Node
\draw (318,221) node [anchor=north west][inner sep=0.75pt]   [align=left] {p};
% Text Node
\draw (160,92) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\Funapp{\id{A}}{(\earg{\_}{\ileft})}$};
% Text Node
\draw (160,222) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\Funapp{\id{A}}{(\earg{\_}{\iright})}$};
% Text Node
\draw (351,150.92) node [anchor=north west][inner sep=0.75pt]  [rotate=-0.06] [align=left] {toPathOver};

\end{tikzpicture}
\end{center}

The circles represent the two types and points in the circle are elements of the corresponding types. With our definition of equality, we can trivially construct an equality between $\Funapp{\id{A}}{(\earg{\_}{\ileft})}$ and $\Funapp{\id{A}}{(\earg{\_}{\iright})}$. Now, given that the two circles are `equal', intuitively speaking, every point in one circle should have a counterpart in the other circle, and this can be obtained transporting a point along the equality between the two types. The result of transporting $\id{x}$ to the type $\Funapp{\id{A}}{(\earg{\_}{\iright})}$ is a point that we shall call $\id{transport\_x}$. Additionally, suppose also that we have an equality between $\id{transport\_x}$ and $\id{y}$, this is indicated by the path $\id{p}$ between the two points in the diagram. Given that $\id{x}$ is transported to $\id{transport\_x}$, and that $\id{transport\_x}$ is equal to $\id{y}$, we also want to be able to say something about the relationship between $\id{x}$ and $\id{y}$. Since they are not of the same type, all we can do is construct a heterogeneous equality between them, and this is precisely what the function $\id{toPathOver}$ seeks to do.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
toPathOver : (A : I @$\Rrightarrow$@ Type) @$\Rrightarrow$@ (x : A (_ := i0)) @$\Rightarrow$@ (y : A (_ := i1))
             @$\Rightarrow$@ Eq (Eq_cast (p := Eq_eq (f := A)) (f := id) x) y
             @$\rightarrow$@ Heq x y;
toPathOver = @$\lambda$@ _  A @$\Rrightarrow$@ @$\lambda$@ x y @$\Rightarrow$@ @$\lambda$@ p @$\rightarrow$@
  let
    l : Heq x (Eq_cast (p := Eq_eq (f := A)) (f := id) x);
    l = Heq_eq (t := A)
               (f := @$\lambda$@ i @$\Rrightarrow$@
                     I_transp (A := (@$\lambda$@ j @$\Rrightarrow$@ A (_ := I_meet i j)))
                              (r := I_not i) x);
  in
    Eq_cast
        (x := (Eq_cast (p := Eq_eq (f := A)) (f := id) x))
        (y := y)
        (p := p) (f := @$\lambda$@ y' @$\rightarrow$@ Heq x y') l;
\end{minted}

We construct a heterogeneous equality between $\id{x}$ and $\id{transport\_x}$ and we concatenate it with the equality proof between $\id{transport\_x}$ and $\id{y}$ to complete the proof.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
elimProp : (A : Type_ ?) @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type)
           @$\Rrightarrow$@ (P : Quotient A R @$\rightarrow$@ Type)
           @$\Rrightarrow$@ (prop : (x : Quotient A R) @$\rightarrow$@ isProp (P x))
           @$\rightarrow$@ (f : (x : A) @$\rightarrow$@ P (Quotient_in x))
           @$\rightarrow$@ (x : Quotient A R) @$\rightarrow$@ P x
elimProp = @$\lambda$@ _ _ _ A R P @$\Rrightarrow$@ @$\lambda$@ prop f @$\rightarrow$@
  Quotient_elim
    (R := R) (P := P) f
    (p := @$\lambda$@ a a' r @$\rightarrow$@
      let
        a=a' : Eq (t := Quotient A R) (Quotient_in a) (Quotient_in a')
        a=a' = Quotient_eq (R := R) (a := a) (a' := a') r
        fa=fa' : Heq (f a) (f a')
        fa=fa' = toPathOver
                    (A := @$\lambda$@ i @$\Rrightarrow$@ P (Eq_uneq (p := a=a') (i := i)))
                    (prop (Quotient_in a')
                          (Eq_cast (p := a=a') (f := P) (f a))
                          (f a'))
      in
        fa=fa')
\end{minted}

$\fn{toPathOver}$ does the heavy lifting in this proof by allowing us to leverage $\Funapp{\fn{isProp}}{(\Funapp{\id{P}}{\id{x}})}$ to easily produce a proof of $\Funapp{\id{Heq}}{(\Funapp{\id{f}}{\id{a}})}{(\Funapp{\id{f}}{\id{a}'})}$. We can also iterate this to define $\fn{elimProp}_2$, $\fn{elimProp}_3$ etc. In general, we can define $\fn{elimProp}_n$ in terms of $\fn{elimProp}_{n-1}$ and $\fn{elimProp}$. To illustrate this, we define $\fn{elimProp}_2$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
elimProp2 : (A B : Type)
            @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type) @$\Rrightarrow$@ (S : B @$\rightarrow$@ B @$\rightarrow$@ Type)
            @$\Rrightarrow$@ (P : Quotient A R @$\rightarrow$@ Quotient B S @$\rightarrow$@ Type)
            @$\Rrightarrow$@ (prop : (x : Quotient A R) @$\rightarrow$@ (y : Quotient B S)
                       @$\rightarrow$@ isProp (P x y))
            @$\rightarrow$@ (f : (x : A) @$\rightarrow$@ (y : B) @$\rightarrow$@ P (Quotient_in x) (Quotient_in y))
            @$\rightarrow$@ (x : Quotient A R) @$\rightarrow$@ (y : Quotient B S) @$\rightarrow$@ P x y
elimProp2 = @$\lambda$@ _ _ _ _ _ A B R S P @$\Rrightarrow$@ @$\lambda$@ prop f @$\rightarrow$@
  elimProp (P := @$\lambda$@ x @$\rightarrow$@ (y : Quotient B S) @$\rightarrow$@ P x y)
           (@$\lambda$@ x @$\rightarrow$@ isProp@$\Pi$@ (B := P x) (prop x))
           (@$\lambda$@ a @$\rightarrow$@ elimProp (P := P (Quotient_in a))
                            (prop (Quotient_in a)) (f a))
\end{minted}

\section{Functional Extensionality}\label{sec:quot-implies-funext}

In intensional type theory, functional extensionality is a property that is
respected by all functions, however, typically this may not be proven. In this
section, we demonstrate that the existence of quotient types implies functional
extensionality.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
funext : (A : Type_ ?) @$\rightarrow$@ (B : A @$\rightarrow$@ Type_ ?)
         @$\rightarrow$@ (f1 : (a : A) @$\rightarrow$@ B a) @$\rightarrow$@ (f2 : (a : A) @$\rightarrow$@ B a)
         @$\rightarrow$@ (h : (a : A) @$\rightarrow$@ f1 a @$\equiv$@ f2 a) @$\rightarrow$@ f1 @$\equiv$@ f2
funext A B f1 f2 h =
  let
    fn_type = (a : A) @$\rightarrow$@ B a

    equiv_rel : (f1 : fn_type) @$\rightarrow$@ (f1 : fn_type) @$\rightarrow$@ Type_ ?
    equiv_rel f1 f2 = ((a : A) @$\rightarrow$@ f1 a @$\equiv$@ f2 a)

    extfun_app : (f : Quotient fn_type equiv_rel) @$\rightarrow$@ fn_type
    extfun_app f a = Quotient_rec (R := equiv_rel)
                                  (f := lambda f @$\rightarrow$@ f a)
                                  (p := lambda f1 f2 r @$\rightarrow$@ r a) f

    sound : Quotient_in (R := equiv_rel) f1 @$\equiv$@ Quotient_in (R := equiv_rel) f2
    sound = Quotient_eq (R := equiv_rel) (a := f1) (a' := f2) h

  in
    Eq_cong extfun_app sound
\end{minted}

We quotient functions by a relation \id{equiv\_rel} that represents pointwise
n
equality. By making use of $\beta$-rule of \id{Quotient\_rec} and the
$\eta$-equivalence of functions, we construct the desired proof by using the
congruence property of equality.

\chapter{Relationship to Category Theory}
There is an intricate relationship between logic, programming (type theory), and
category theory, as was proposed by Harper\cite{harpertrinity}. Everything that
exists in each of these domains necessarily has an interesting analogue in the
other two. In previous chapters, we have motivated quotients by drawing
parallels with set theory. We now discuss quotients from the perspective of
category theory. In some cases, this will motivate the `discovery' of some
interesting properties of the $\id{Quotient}$ type.

%% TODO: Maybe I should reconsider how much value is added by having this here
%% honestly, I'm starting to have second thoughts... If this can inspire a few
%% interesting theorems out about Quotient types it'd be more interesting

Numerous constructs in type theory have equivalents in category theory. To set
the stage for this, we shall do a very short primer on category theory. For a
more detailed introduction, interested readers are directed to other works such
as Awodey's textbook\cite{awodey-cattheory}.

\section{Introduction}
Category theory is built on merely a few foundational constructs, these alone
give rise to a lot of interesting structures and properties. First, we postulate
the existence of categories that contain objects. Next, we say that objects can
be related to other objects via morphisms (also known as arrows, these two terms
shall be used interchangeably in the following discussion). Assuming that
readers are familiar with programming and/or type theory, one could think of
categories as types, objects as terms of a particular type, and morphisms as
functions. Every object has an identity arrow that relates it to itself.

\begin{figure}[H]
\centering
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Ellipse [id:dp9346439808655433]
\draw   (220,155) .. controls (220,113.58) and (275.96,80) .. (345,80) .. controls (414.04,80) and (470,113.58) .. (470,155) .. controls (470,196.42) and (414.04,230) .. (345,230) .. controls (275.96,230) and (220,196.42) .. (220,155) -- cycle ;
%Shape: Circle [id:dp22784360669527182]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (262,145.33) .. controls (262,142.56) and (264.24,140.33) .. (267,140.33) .. controls (269.76,140.33) and (272,142.56) .. (272,145.33) .. controls (272,148.09) and (269.76,150.33) .. (267,150.33) .. controls (264.24,150.33) and (262,148.09) .. (262,145.33) -- cycle ;
%Curve Lines [id:da27074905740711297]
\draw    (272,140.33) .. controls (292.91,130.36) and (285.32,171.14) .. (268.07,151.6) ;
\draw [shift={(267,150.33)}, rotate = 51.34] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;
%Shape: Circle [id:dp9211255412324888]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (400,147) .. controls (400,144.24) and (402.24,142) .. (405,142) .. controls (407.76,142) and (410,144.24) .. (410,147) .. controls (410,149.76) and (407.76,152) .. (405,152) .. controls (402.24,152) and (400,149.76) .. (400,147) -- cycle ;
%Curve Lines [id:da7233344958507704]
\draw    (410,142) .. controls (430.91,132.04) and (423.32,172.81) .. (406.07,153.27) ;
\draw [shift={(405,152)}, rotate = 51.34] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;
%Curve Lines [id:da38568823352847637]
\draw    (267,150.33) .. controls (263.04,198.67) and (387.15,206.66) .. (399.66,151.69) ;
\draw [shift={(400,150)}, rotate = 102.82] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;
%Shape: Circle [id:dp8096171242464965]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (340,105) .. controls (340,102.24) and (342.24,100) .. (345,100) .. controls (347.76,100) and (350,102.24) .. (350,105) .. controls (350,107.76) and (347.76,110) .. (345,110) .. controls (342.24,110) and (340,107.76) .. (340,105) -- cycle ;
%Curve Lines [id:da10314349904359177]
\draw    (352,100) .. controls (372.91,90.04) and (365.32,130.81) .. (348.07,111.27) ;
\draw [shift={(347,110)}, rotate = 51.34] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;

% Text Node
\draw (197,145.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {A};
% Text Node
\draw (251,132.33) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {x};
% Text Node
\draw (283,132.33) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {id\_x};
% Text Node
\draw (389,134) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {y};
% Text Node
\draw (423,144) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {id\_y};
% Text Node
\draw (351,192) node [anchor=north west][inner sep=0.75pt]   [align=left] {f};
% Text Node
\draw (363,92) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {id\_z};
% Text Node
\draw (329,94) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {z};


\end{tikzpicture}
\caption{Example of a category A with objects x, y and z with a morphism f that goes from x to y}
\end{figure}

At the heart of category theory, we have the notion of composition. Suppose that we have an arrow from A to B, and another arrow from B to C, then there is necessarily another arrow that goes directly from A to C. We call this the composition of the first two arrows. This is of course analogous to function composition in programming.

\begin{figure}[H]
\centering

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Ellipse [id:dp5682347326089148]
\draw   (210,155) .. controls (210,113.58) and (265.96,80) .. (335,80) .. controls (404.04,80) and (460,113.58) .. (460,155) .. controls (460,196.42) and (404.04,230) .. (335,230) .. controls (265.96,230) and (210,196.42) .. (210,155) -- cycle ;
%Shape: Circle [id:dp9592501831446234]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (253,160.06) .. controls (253,157.3) and (255.24,155.06) .. (258,155.06) .. controls (260.76,155.06) and (263,157.3) .. (263,160.06) .. controls (263,162.82) and (260.76,165.06) .. (258,165.06) .. controls (255.24,165.06) and (253,162.82) .. (253,160.06) -- cycle ;
%Shape: Circle [id:dp2931536659208638]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (328,110.06) .. controls (328,107.3) and (330.24,105.06) .. (333,105.06) .. controls (335.76,105.06) and (338,107.3) .. (338,110.06) .. controls (338,112.82) and (335.76,115.06) .. (333,115.06) .. controls (330.24,115.06) and (328,112.82) .. (328,110.06) -- cycle ;
%Curve Lines [id:da24285465512107507]
\draw    (338,110.06) .. controls (364.46,112.94) and (388.04,119.72) .. (416.27,152.99) ;
\draw [shift={(418,155.06)}, rotate = 229.87] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;
%Curve Lines [id:da2451569195346175]
\draw    (258,160.06) .. controls (258.98,139.48) and (278.21,117.88) .. (325.09,110.49) ;
\draw [shift={(328,110.06)}, rotate = 171.94] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;
%Shape: Circle [id:dp5266322522520346]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (413,160.06) .. controls (413,157.3) and (415.24,155.06) .. (418,155.06) .. controls (420.76,155.06) and (423,157.3) .. (423,160.06) .. controls (423,162.82) and (420.76,165.06) .. (418,165.06) .. controls (415.24,165.06) and (413,162.82) .. (413,160.06) -- cycle ;
%Curve Lines [id:da19962913311880914]
\draw    (258,160.06) .. controls (289.52,210.24) and (385.07,210.02) .. (416.6,167.05) ;
\draw [shift={(418,165.06)}, rotate = 123.72] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (7.14,-3.43) -- (0,0) -- (7.14,3.43) -- cycle    ;

% Text Node
\draw (321,91) node [anchor=north west][inner sep=0.75pt]   [align=left] {B};
% Text Node
\draw (241,151) node [anchor=north west][inner sep=0.75pt]   [align=left] {A};
% Text Node
\draw (426,151) node [anchor=north west][inner sep=0.75pt]   [align=left] {C};
% Text Node
\draw (268,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {f};
% Text Node
\draw (388,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {g};
% Text Node
\draw (321,201) node [anchor=north west][inner sep=0.75pt]   [align=left] {g $\circ$ f};

\end{tikzpicture}

\caption{The composition of two morphisms f and g. The identity arrows are not explicitly shown as we can take their existence for granted.}

\end{figure}

To conclude our short introduction to category theory, we would like to present the category-theoretic equivalent of a ubiquitous construct in type theory, i.e.\ products (also known as tuples). One should be familiar with the notion of products being defined as pairs of elements, however in category theory, we have to define such objects in terms of its morphisms that relate it to other objects. If some object C were to be the product of objects A and B, then we require that it has two morphisms that behave as the first and second projections out of the product. In other words, we require the two morphisms $\id{p} : \id{C} \rightarrow \id{A}$ and $\id{q} : \id{C} \rightarrow \id{B}$.

\begin{figure}[H]
  \centering

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Circle [id:dp07095704485213461]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (339.5,95.06) .. controls (339.5,92.3) and (341.74,90.06) .. (344.5,90.06) .. controls (347.26,90.06) and (349.5,92.3) .. (349.5,95.06) .. controls (349.5,97.82) and (347.26,100.06) .. (344.5,100.06) .. controls (341.74,100.06) and (339.5,97.82) .. (339.5,95.06) -- cycle ;
%Shape: Circle [id:dp6029113112328306]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (380.5,165.06) .. controls (380.5,162.3) and (382.74,160.06) .. (385.5,160.06) .. controls (388.26,160.06) and (390.5,162.3) .. (390.5,165.06) .. controls (390.5,167.82) and (388.26,170.06) .. (385.5,170.06) .. controls (382.74,170.06) and (380.5,167.82) .. (380.5,165.06) -- cycle ;
%Shape: Circle [id:dp8272191866621565]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (299.5,165.06) .. controls (299.5,162.3) and (301.74,160.06) .. (304.5,160.06) .. controls (307.26,160.06) and (309.5,162.3) .. (309.5,165.06) .. controls (309.5,167.82) and (307.26,170.06) .. (304.5,170.06) .. controls (301.74,170.06) and (299.5,167.82) .. (299.5,165.06) -- cycle ;
%Straight Lines [id:da6629962247946746]
\draw    (344.5,95.06) -- (308.96,158.88) ;
\draw [shift={(307.5,161.5)}, rotate = 299.11] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;
%Straight Lines [id:da8118877575329375]
\draw    (344.5,95.06) -- (381.49,158.41) ;
\draw [shift={(383,161)}, rotate = 239.72] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;

% Text Node
\draw (338,71.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {C};
% Text Node
\draw (382,171.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {B};
% Text Node
\draw (298,171.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {A};
% Text Node
\draw (299,110.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {p};
% Text Node
\draw (371,110) node [anchor=north west][inner sep=0.75pt]   [align=left] {q};

\end{tikzpicture}

\caption{A candidate product of A and B with its projection morphisms.}

\end{figure}

However, we notice that this is far too general of a definition since it is
likely that many objects fulfil these criteria. Here, we
introduce the notion of a universal property which allows us to identify
\emph{the best product}. The best product is the one that is not too general,
and yet not too restrictive, it is \emph{just right}. More formally, the product
of $\id{A}$ and $\id{B}$ is an object $\id{A} \times \id{B}$ with the morphisms
$\pi_1 : \id{A} \times \id{B} \rightarrow A$ and $\pi_2 : \id{A} \times \id{B}
\rightarrow B$. Additionally, for any other object $\id{C}$ with morphisms
$\id{p} : \id{C} \rightarrow \id{A}$ and $\id{q} : \id{C} \rightarrow \id{B}$,
there exists a unique morphism $\id{f}$ such that $\id{p} = \pi_1 \circ \id{f}$
and $\id{q} = \pi_2 \circ \id{f}$. In other words, we require that the following
diagram commute:

\begin{figure}[H]
\centering

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Circle [id:dp8623415585531431]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (350.7,165.46) .. controls (350.7,162.7) and (352.94,160.46) .. (355.7,160.46) .. controls (358.46,160.46) and (360.7,162.7) .. (360.7,165.46) .. controls (360.7,168.22) and (358.46,170.46) .. (355.7,170.46) .. controls (352.94,170.46) and (350.7,168.22) .. (350.7,165.46) -- cycle ;
%Shape: Circle [id:dp8629465911347864]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (309.9,214.92) .. controls (309.9,212.16) and (312.14,209.92) .. (314.9,209.92) .. controls (317.66,209.92) and (319.9,212.16) .. (319.9,214.92) .. controls (319.9,217.69) and (317.66,219.92) .. (314.9,219.92) .. controls (312.14,219.92) and (309.9,217.69) .. (309.9,214.92) -- cycle ;
%Shape: Circle [id:dp07686054824860356]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (390.3,215.32) .. controls (390.3,212.56) and (392.54,210.32) .. (395.3,210.32) .. controls (398.06,210.32) and (400.3,212.56) .. (400.3,215.32) .. controls (400.3,218.09) and (398.06,220.32) .. (395.3,220.32) .. controls (392.54,220.32) and (390.3,218.09) .. (390.3,215.32) -- cycle ;
%Straight Lines [id:da5396059636931949]
\draw    (355.7,165.46) -- (320.88,208.66) ;
\draw [shift={(319,211)}, rotate = 308.86] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;
%Straight Lines [id:da09985777044473254]
\draw    (355.7,165.46) -- (389.18,209.28) ;
\draw [shift={(391,211.67)}, rotate = 232.62] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;
%Shape: Circle [id:dp44714117032868783]
\draw  [fill={rgb, 255:red, 23; green, 1; blue, 1 }  ,fill opacity=1 ] (350.03,105.46) .. controls (350.03,102.7) and (352.27,100.46) .. (355.03,100.46) .. controls (357.79,100.46) and (360.03,102.7) .. (360.03,105.46) .. controls (360.03,108.22) and (357.79,110.46) .. (355.03,110.46) .. controls (352.27,110.46) and (350.03,108.22) .. (350.03,105.46) -- cycle ;
%Curve Lines [id:da13360932709149242]
\draw    (355.03,105.46) .. controls (324.14,108.29) and (279.69,163.31) .. (309.58,209.56) ;
\draw [shift={(311,211.67)}, rotate = 235.01] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;
%Curve Lines [id:da35945481458004735]
\draw    (355.03,105.46) .. controls (383.24,107.63) and (430.88,163.29) .. (400.44,208.92) ;
\draw [shift={(399,211)}, rotate = 305.93] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;
%Straight Lines [id:da17703597924842862]
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (355.03,105.46) -- (355.66,157.46) ;
\draw [shift={(355.7,160.46)}, rotate = 269.31] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (8.93,-4.29) -- (0,0) -- (8.93,4.29) -- cycle    ;

% Text Node
\draw (363.87,156.33) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {A $\times$ B};
% Text Node
\draw (306,221.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {A};
% Text Node
\draw (394.67,221) node [anchor=north west][inner sep=0.75pt]   [align=left] {B};
% Text Node
\draw (319.33,175.33) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\displaystyle \pi _{1}$};
% Text Node
\draw (374.67,175.6) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\displaystyle \pi _{2}$};
% Text Node
\draw (365.33,91) node [anchor=north west][inner sep=0.75pt]   [align=left] {C};
% Text Node
\draw (294.67,126) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\displaystyle p$};
% Text Node
\draw (403.33,125.33) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\displaystyle q$};
% Text Node
\draw (340,124.67) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\displaystyle f$};

\end{tikzpicture}

\caption{Universal mapping property of the product}

\end{figure}

Another way of saying the above is that $\id{h}$ factorises $\id{p}$ and
$\id{q}$. The universal product, if it exists, is unique up to isomorphism.
Products are not guaranteed to exist in every category. In the category of sets,
the universal product is none other than the Cartesian product.

\section{Coequaliser}\label{sec:coequaliser}
We now introduce the notion of a coequaliser. We shall see later that
$\kw{Quotient}$ acts indeed as a coequaliser, or rather coequalisers are
generalisation of quotients. For two arrows $\oftype{f, g}{A \rightarrow B}$, a
coequaliser is an arrow $\oftype{q}{B \rightarrow Q}$ such that $qf = qg$ (we
use juxtaposition to imply composition). The universal property of the
coequaliser then dictates that for any other $Z$ and $\oftype{z}{B \rightarrow
  Z}$, if $zf = zg$, then there must exist a unique $\oftype{u}{Q \rightarrow
  Z}$ such that $uq = g$. This allows us to call $q$ \textbf{the} coequaliser of
$f$ and $g$.

\begin{figure}[H]
  \centering
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Straight Lines [id:da9967367962188358]
\draw    (208,127) -- (285,127) ;
\draw [shift={(288,127)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da10808455754917401]
\draw    (208,134.33) -- (285,134.33) ;
\draw [shift={(288,134.33)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da5630721975359221]
\draw    (305.33,130) -- (382.33,130) ;
\draw [shift={(385.33,130)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da6026678626663149]
\draw    (304.33,136.33) -- (385.47,188.05) ;
\draw [shift={(388,189.67)}, rotate = 212.52] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da1216641628607622]
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (392.67,137) -- (392.67,178.33) ;
\draw [shift={(392.67,181.33)}, rotate = 270] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;

% Text Node
\draw (191,122) node [anchor=north west][inner sep=0.75pt]  [font=\normalsize] [align=left] {A};
% Text Node
\draw (292,121.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {B};
% Text Node
\draw (386.17,121.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {Q};
% Text Node
\draw (388.67,181) node [anchor=north west][inner sep=0.75pt]   [align=left] {Z};
% Text Node
\draw (241.33,108.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {f};
% Text Node
\draw (241.33,137.33) node [anchor=north west][inner sep=0.75pt]   [align=left] {g};
% Text Node
\draw (341.67,111) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {q};
% Text Node
\draw (338.67,163) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {z};
% Text Node
\draw (398.33,152) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {u};


\end{tikzpicture}

\caption{Illustration of a coequaliser}

\end{figure}

\textbf{Proposition} In any category, if $\oftype{q}{B \rightarrow Q}$ is a coequaliser of a pair of arrows $\oftype{f, \ g}{A \rightarrow B}$, then $q$ is an epimorphism.

Proof.

We first state the definition of an epimorphism. An epimorphism is a morphism $\oftype{f}{X \rightarrow Y}$ such that for all objects C and morphisms $\oftype{g_1, g_2}{Y \rightarrow Z}$, if $g_1f = g_2f$ then $g_1 = g_2$.

Now, we consider the below diagram

\begin{figure}[H]
  \centering
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Straight Lines [id:da5779265165541632]
\draw    (208,127) -- (285,127) ;
\draw [shift={(288,127)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da20539623997737722]
\draw    (208,134.33) -- (285,134.33) ;
\draw [shift={(288,134.33)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da259761440148945]
\draw    (305.33,130) -- (382.33,130) ;
\draw [shift={(385.33,130)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da923412514180374]
\draw    (304.33,136.33) -- (385.47,188.05) ;
\draw [shift={(388,189.67)}, rotate = 212.52] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da6028721128255661]
\draw    (389.67,137.5) -- (389.67,178.83) ;
\draw [shift={(389.67,181.83)}, rotate = 270] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da20084318131652013]
\draw    (398.17,137.5) -- (398.17,178.83) ;
\draw [shift={(398.17,181.83)}, rotate = 270] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;

% Text Node
\draw (191,122) node [anchor=north west][inner sep=0.75pt]  [font=\normalsize] [align=left] {A};
% Text Node
\draw (292,121.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {B};
% Text Node
\draw (386.17,121.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {Q};
% Text Node
\draw (388.67,181) node [anchor=north west][inner sep=0.75pt]   [align=left] {Z};
% Text Node
\draw (241.33,108.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {f};
% Text Node
\draw (241.33,137.33) node [anchor=north west][inner sep=0.75pt]   [align=left] {g};
% Text Node
\draw (341.67,111) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {q};
% Text Node
\draw (338.67,163) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {z};
% Text Node
\draw (377.83,150.5) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {x};
% Text Node
\draw (399.83,151) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {y};

\end{tikzpicture}
\end{figure}

in which $q$ is the coequaliser of $f$ and $g$. Supposing that $xq = yq$, we need to show that $x = y$. We have that $z = xq = yq$, implying that $zf = xqf = xqg = zg$. By the universal property of the coequaliser, there exists a unique $u$ such that $z = uq$. Since $z = xq$ and $z = yq$, it must be the case that $u = x = y$. Hence, $q$ is epic.

Suppose that $R$ is a pair of some set X that is related by some equivalence
relation, such that there are morphisms $\oftype{\pi_1, \pi_2}{R \rightarrow X}$
that act as projections out of the pair. Then, the surjection into the quotient,
$\oftype{q}{X \rightarrow X/R}$ is an coequaliser of $\pi_1$ and $\pi_2$. Its
counterpart in Typer is the function $\kw{Quotient\_in}$. Since the coequaliser
is epic, this implies that $\kw{Quotient\_in}$ is surjective, as can be proven
within Typer. When we say that a function $\oftype{f}{X \rightarrow Y}$ is
surjective, we are essentially saying that $\forall y \in Y. \ \exists x \in X.
\ f(x) = y$. Note that we should represent this by a weak sum, i.e.\ we do not
require a concrete witness of $x$.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
type SurjectiveQuotientProof (A : Type) (R : A -> A -> Type)
                             (x : Quotient A R) : Type
   | surjectiveQuotientProof (a : A) (Eq (Quotient_in (R := R) a) x);
\end{minted}

We define the above type, intending to return the propositional truncation of it as a proof of the surjectivity of $\kw{Quotient\_in}$. The proof goes as follows:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Quotient_in_surjective : (A : Type) @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type)
                         @$\Rrightarrow$@ (x : Quotient A R)
                         @$\rightarrow$@ PropTrunc (SurjectiveQuotientProof A R x)
Quotient_in_surjective = lambda A R @$\Rrightarrow$@
  elimProp (@$\lambda$@ x @$\rightarrow$@ squash (P := SurjectiveQuotientProof A R x))
           (@$\lambda$@ a @$\rightarrow$@ inPropTrunc (surjectiveQuotientProof a Eq_refl))
\end{minted}

Additionally, if we have an $\oftype{f}{X \rightarrow Y}$ such that it respects
the underlying equivalence relation, i.e. $f \circ \pi_1 = f \circ \pi_2$, then
there exists a unique function $\oftype{\overline{f}}{X/R \rightarrow Y}$. For
$x \in X$, we have that $f(x) = \overline{f}(q(x))$. The equivalent of
$\overline{f}$ in Typer is the function
$\Funapp{\id{Quotient\_elim}}{f}{(\earg{p}{p})}$ where $p$ is an appropriate
proof that $f$ respects the relation. This also justifies the reduction rule of
\id{Quotient\_elim} which says that the application of \id{Quotient\_elim} to
some function \id{f} and an surjection of some term \id{x} into the quotient
should reduce to the direct application of \id{f} to \id{x}.

\begin{figure}[H]
  \centering

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Straight Lines [id:da7734725100317463]
\draw    (228,147) -- (305,147) ;
\draw [shift={(308,147)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da007971811961900777]
\draw    (228,154.33) -- (305,154.33) ;
\draw [shift={(308,154.33)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da3202673895090322]
\draw    (325.33,150) -- (402.33,150) ;
\draw [shift={(405.33,150)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da7225860259717922]
\draw    (324.33,156.33) -- (405.47,208.05) ;
\draw [shift={(408,209.67)}, rotate = 212.52] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
%Straight Lines [id:da21057174956898383]
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (412.33,157.17) -- (412.33,198.5) ;
\draw [shift={(412.33,201.5)}, rotate = 270] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;

% Text Node
\draw (211,142) node [anchor=north west][inner sep=0.75pt]  [font=\normalsize] [align=left] {R};
% Text Node
\draw (312,141.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {X};
% Text Node
\draw (406.17,141.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {Q};
% Text Node
\draw (408.67,201) node [anchor=north west][inner sep=0.75pt]   [align=left] {Y};
% Text Node
\draw (261.33,128.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \pi _{1}$};
% Text Node
\draw (261.33,157.33) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \pi _{2}$};
% Text Node
\draw (361.67,131) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {q};
% Text Node
\draw (358.67,183) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {f};
% Text Node
\draw (400.5,170.17) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\overline{f}$};

\end{tikzpicture}

\end{figure}

We can also phrase the universal property of $\kw{Quotient}$ in a type-theoretic
way as follows:

\begin{align*}
  & (X/R \rightarrow Y) \simeq \Sigma \ (X \rightarrow Y) \ (\lambda \ f \rightarrow (x \ y : X) \rightarrow \Funapp{R}{x}{y} \rightarrow \Funapp{f}{x} \equiv \Funapp{f}{y}) \\
\end{align*}

This property says that a map between the quotient \fn{X/R} to some type \id{Y}
is equivalent to some function of type \fn{X $\rightarrow$ Y} accompanied with a
proof that the function respects the quotient. This may be proven within Typer
itself, the proof is provided in \autoref{app:ump-quot} of the appendix.

\chapter{Related works}

%% NOTE: I'm going to try to make this chapter more approachable, with the
%% intention of moving it to to start (chapter 2). Sequence of presentation
%% - miranda laws
%% - normalised types
%% - HITs
%% - QITs

%% SM: I expected in this section to see a presentation of Miranda's
%% "quotient-like" types, and Courtieu's quotient types (and possibly other
%% quotient types in Coq like Cohen's).
%% Also, when talking about Cubical Agda (which should have its own
%% (sub)section), I expected to see something
%% explaining how instead of adding a separate notion of quotient type,
%% they extended inductive types to HITs.
%% And rather than just have a Quotient Haskell example within the QIT
%% section, I expected a (sub)section about Quotient Haskell.
%% IOW, this section should talk about existing implementations of
%% (variations of) the concept rather than about variants of the
%% concept themselves.

In this chapter, we present works that are related to ours. We show where we
drew our inspiration from and we also take this opportunity to give readers a
taste of what quotient types are like and what they are capable of.

\section{Miranda}

The Miranda programming language's\cite{thompson1986laws, thompson1990lawful}
primary innovation that interests us is its \emph{laws}. These laws may be
specified during the definition of algebraic data types and they act as rewrite
rules. Rewrites are automatically applied to terms of the data type such that
they shall always be in \emph{normal} form. To illustrate this, we show a
definition of the integer data type.

\begin{minted}{haskell}
integer :: Zero |
           Succ integer |
           Pred integer
\end{minted}

Such a definition gives rise to many redundant terms, each integer has an
infinite amount of representations. For instance, the integer \id{Zero} may also
be represented as \fn{Succ (Pred Zero)}, \fn{Pred (Succ Zero)}, etc. This is
where laws come into play, since the composition of \id{Succ} with \id{Pred}
should be equal to the identity function, we define the following laws:

\begin{minted}{haskell}
Succ (Pred n) => n
Pred (Succ n) => n
\end{minted}

Types that are constrained by laws are known as \emph{lawful types}. Laws may
also be defined with conditions so that rewriting only takes place when the
appropriate conditions are fulfilled. To illustrate this, we define the type of
rational numbers on top of the built-in integer type, \id{num}. The laws are
conceived in a way such that negative rational numbers will always have a
negative numerator and a positive denominator. We also want the rational numbers
to be as `simplified' as possible, i.e.\ we want the numerator and denominator
to be coprime.

\begin{minted}{haskell}
rational ::= Rat num num

Rat a b => error "zero denominator", b == O
        => Rat (-a) (-b),            b < O
        => Rat a' b',                g > 1
           where
           a' = a div g
           b' = b div g
           g = gcd a b
\end{minted}

Functions that act on lawful types enjoy the convenience of being able to assume
that their arguments will always be in normal form. In other words, programmers
need not worry about normalisation both before and after computation as this is
taken care of by the language itself. We may define the addition operation on
rationals via pattern-matching with a syntax that is reminiscent of Haskell.

\begin{minted}{haskell}
radd :: rational -> rational -> rational
radd (Rat x1 y1) (Rat x2 y2) = Rat ((x1 mul y2) add (x2 mul y1)) (y1 mul y2)
\end{minted}

Indeed, laws in Miranda are no more than smart constructors in disguise.
Nevertheless, they highlight the fact that we often would like to express the
fact certain terms of our algebraic data types are equal.

\section{Normalised Types}\label{sec:normalised-types-courtieu}

Courtieu's normalised types\cite{courtieu-normalizedtypes} may be seen as an
effort to introduce a system that allows us to express a normalisation scheme
for terms of a certain type to dependent type theory. More specifically,
Courtieu conceived the above as an extension to the Calculus of Inductive
Constructions (CIC)\cite{werner-cic}, a dependent type theory that serves as the
backbone of many modern proof assistants in some shape or form. It turns out
that the extended calculus may be translated to the CIC itself, implying that
desirable properties of the CIC are preserved by this extension. The overall
challenge was to ensure that normalised types exhibit the appropriate
computational and logical behaviours all while maintaining the consistency of
the system.

To construct a normalised type on top of a base type \id{A}, we first construct
a normalisation function of type \fn{A $\rightarrow$ A}. In a way, this is
similar to Miranda's laws, but instead of enumerating them, they are packaged
into a single function. We can then construct the type \fn{\kw{Norm}(A, nf)}
which represents the type \id{A} normalised by \id{nf}. Elements of the type
have the form \fn{\kw{Class}(A, nf, t)} where \id{t} is a term of type \id{A}.
Conceptually, when we take the quotient of a type, we are essentially
partitioning the base type into equivalence classes as suggested by the example
in \autoref{fig:eq-class-zmod4}. Indeed, normalised types allow us to represent
a special case of quotient types where we can elect a canonical representative
for every equivalence class using a normalisation function. If we have two terms
\id{t} and \id{t'} that share the same normal form, then we could expect
\fn{\kw{Class}(A, nf, t)} and \fn{\kw{Class}(A, nf, t')} to be equal. Indeed,
Courtieu's extension of the CIC benefits from having the above equality hold
judgementally by virtue of an augmentation of the internal conversion and
equality rules.

To eliminate a term \id{u} of type \fn{\kw{Norm}(A, nf)}, we use the
\kw{ElimNorm} primitive. By using a function \fn{f : A $\rightarrow$ B}, we can
build the term \fn{\kw{ElimNorm}(A, nf, f, u) : B}. The eliminator has the
expected computation rule \fn{\kw{ElimNorm}(A, nf, f, \kw{Class}(A, nf, t))
  $\rightsquigarrow{}$ f (nf t)}.

The idempotence of the normalisation function is not required, and thus the
system takes care to only apply it once to the underlying term of the base type.
This leads to the observation that the normalisation function may be further
generalised such that it should not be restricted to producing terms of the same
type. For instance, if we would like to construct the type of integers mod 2, it
would be reasonable to define a normalised type with a normalisation function of
type \fn{Integer $\rightarrow$ Boolean}. This was not implemented in Courtieu's
original work, but we believe that this is a perfectly reasonable extension of
his system.

\begin{figure}
  \centering
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Ellipse [id:dp4829810342761349]
\draw  [color={rgb, 255:red, 140; green, 66; blue, 66 }  ,draw opacity=1 ][fill={rgb, 255:red, 208; green, 162; blue, 162 }  ,fill opacity=1 ] (171,152.5) .. controls (171,100.86) and (237.71,59) .. (320,59) .. controls (402.29,59) and (469,100.86) .. (469,152.5) .. controls (469,204.14) and (402.29,246) .. (320,246) .. controls (237.71,246) and (171,204.14) .. (171,152.5) -- cycle ;
%Curve Lines [id:da7772387220169334]
\draw    (172,165) .. controls (220,144) and (335,171) .. (320,59) ;
%Curve Lines [id:da0576638127246778]
\draw    (264.2,147.6) .. controls (366.2,188.6) and (355,231) .. (314,246) ;
%Curve Lines [id:da8789468342677784fig]
\draw    (315.4,174.4) .. controls (355.4,144.4) and (407.4,213.6) .. (455,114.8) ;

% Text Node
\draw (244,97.6) node [anchor=north west][inner sep=0.75pt]   [align=left] {[ 0 ]};
% Text Node
\draw (356,116.8) node [anchor=north west][inner sep=0.75pt]   [align=left] {[ 1 ]};
% Text Node
\draw (250.4,186.4) node [anchor=north west][inner sep=0.75pt]   [align=left] {[ 2 ]};
% Text Node
\draw (383.6,192) node [anchor=north west][inner sep=0.75pt]   [align=left] {[ 3 ]};


\end{tikzpicture}
\caption{Equivalence classes of $\mathbb{Z}$ under the relation $x \equiv y \ (\kw{mod} \ 4)$}\label{fig:eq-class-zmod4}
\end{figure}

%% SM: Hmm... the rest of this section seems to go firmly outside "related
%% work" territory.

%% NOTE: I think that maybe its not interesting to show the entire construction,
%% it is sufficient to simply mention the possibility of doing so and direct
%% interested readers to the book for more details

%% Quotients based on normalisation may actually be represented in Typer without
%% extending the language. Indeed, this can be done in any language that supports
%% coproducts, as is suggested in\cite{HoTTbook}. This is unsurprising given that
%% Courtieu's implementation may also be translated to the Calculus of Inductive
%% Constructions\cite{werner-cic}, a close relative of Typer. We now describe the
%% aforementioned construction in Typer, and then provide a proof that it fulfils
%% the universal property of a quotient.

%% We define a dependent pair as follows (this is why coproducts are related):

%% \begin{minted}[escapeinside=@@,mathescape=true]{haskell}
%% type Sigma (A : Type) (B : A @$\rightarrow$@ Type)
%%   | sigma (fst : A) (snd : B fst);
%% \end{minted}

%% Now, we can define the type $\kw{Qnorm}$ for some type $\id{A}$ and
%% normalisation function $\oftype{r}{A \rightarrow A}$ as a dependent pair that
%% contains some term of type $\id{A}$ and a proof that it has been normalised.
%% This of course requires the idempotency of the normalisation function. We note
%% as well that generally speaking, the codomain of the normalisation function need
%% not be of the same type as its domain, however for the purposes of this
%% construction such a constraint is necessary.

%% \begin{minted}[escapeinside=@@,mathescape=true]{haskell}
%% Qnorm : (A : Type) @$\rightarrow$@ isSet A @$\rightarrow$@ (r : A @$\rightarrow$@ A)
%%         @$\rightarrow$@ (i : (x : A) @$\rightarrow$@ Eq (r (r x)) (r x)) @$\rightarrow$@ Type
%% Qnorm A p r i = Sigma A (@$\lambda$@ (x : A) @$\rightarrow$@ Eq (r x) x)
%% \end{minted}

%% The surjection into $\kw{Qnorm}$ is simply the construction of a dependent pair
%% containing a term that has been normalised and a proof of its normalisation.
%% This is in contrast to the construction that was described previously with
%% $\kw{Quotient}$ which applied the normalisation upon the elimination of a
%% quotient, whereas here, normalisation immediately occurs upon the construction
%% of a term of type $\kw{Qnorm}$.

%% We can prove that the equality of $\kw{Qnorm}$ terms is characterised by the
%% equality between the normalised forms of the underlying terms. As usual, we
%% require $\Funapp{\kw{isSet}}{\id{A}}$ to prove this equality. A simple
%% invocation of the \fn{${\Sigma}{\equiv}$\_prop} lemma completes the proof.

%% \begin{minted}[escapeinside=@@,mathescape=true]{haskell}
%% Qnorm_eq : (A : Type) @$\Rrightarrow$@ (x y : A) @$\Rightarrow$@ (p : HoTT_isSet A)
%%            @$\Rightarrow$@ (r : A @$\rightarrow$@ A) @$\Rightarrow$@ (i : (x : A) @$\rightarrow$@ Eq (r (r x)) (r x))
%%            @$\Rightarrow$@ Eq (r x) (r y) @$\rightarrow$@ Eq (Qnorm_in (p := p) (r := r) (i := i) x)
%%                                    (Qnorm_in (p := p) (r := r) (i := i) y)
%% Qnorm_eq = @$\lambda$@ A @$\Rrightarrow$@ @$\lambda$@ x y p r i @$\Rightarrow$@ @$\lambda$@ rx@$\equiv$@ry @$\rightarrow$@
%%   @${\Sigma}{\equiv}$@_prop (B := @$\lambda$@ x @$\rightarrow$@ Eq (r x) x)
%%            (@$\lambda$@ x @$\rightarrow$@ p (r x) x)
%%            (sigma (B := @$\lambda$@ x @$\rightarrow$@ Eq (r x) x) (r x) (i x))
%%            (sigma (B := @$\lambda$@ x @$\rightarrow$@ Eq (r x) x) (r y) (i y))
%%            rx@$\equiv$@ry
%% \end{minted}

%% We can easily prove the reverse of this too, i.e.\ if we have that
%% $\Funapp{\kw{Eq}}{(\Funapp{\kw{Qnorm\_in}}{x})}{(\Funapp{\kw{Qnorm\_in}}{y})}$,
%% then $\Funapp{\kw{Eq}}{(\Funapp{r}{x})}{(\Funapp{r}{y})}$ is immediate by taking
%% the first projection of the pairs.

%% Finally, we can also show that $\kw{Qnorm}$ fulfils the universal property of a
%% quotient. In other words, we want show the following equivalence:

%% \begin{align*}
%%   & (\Funapp{\kw{Qnorm}}{A}{p}{r}{i} \rightarrow B) \simeq \Sigma \ (A
%%   \rightarrow B) \ (\lambda g \rightarrow (x \ y : A) \rightarrow \Funapp{r}{x}
%%   \equiv \Funapp{r}{y} \rightarrow \Funapp{g}{x} \equiv \Funapp{g}{y})
%% \end{align*}

%% The proof itself is not very interesting as it is largely similar to the proof
%% of the universal property of \id{Quotient} that is provided in
%% \autoref{app:ump-quot} of the appendix. We note however that the reverse
%% direction of this equivalence characterises the elimination principle of
%% $\id{Qnorm}$, as was the case for $\id{Quotient}$.

\section{Cubical Equality and HITs in Cubical Agda}\label{sec:cubical-agda}

Cubical Agda\cite{vezzosi2021cubical} is an extension of the \Agda{} proof
assistant which serves to provide computational meaning to HoTT. This work is
of particular interest to us because of two of its prominent features, cubical
equality and higher inductive types (HITs). The thing that makes the type theory
cubical is its notion of equality that is represented by functions out of an
interval type, i.e.\ of type \fn{I $\rightarrow$ A}. More specifically, such
equality types are known as \emph{paths} in the literature. If an equality
between two terms is seen as a line, then we may construct an equality between
two lines to produce a square. This process may be iterated to produce cubes,
hypercubes, etc, justifying the name of the type theory. Cubical Agda introduced
the interval type as a primitive with two endpoints \fn{i0 : I} and \fn{i1 : I}.
Unlike normal types, pattern matching on an interval variable is disallowed. The
type of homogeneous equality is represented by $\equiv$ with the following type:

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
_@$\equiv$@_ : {A : Set @$\ell$@} @$\rightarrow$@ A @$\rightarrow$@ A @$\rightarrow$@ Set @$\ell$@
\end{minted}

Readers that are not familiar with \Agda{} are reminded that \fn{\_$\equiv$\_}
means that $\equiv$ is an infix operator\footnote{The underscores indicate where
the arguments should go, in this case, there should be an argument before and
after the $\equiv$ operator.}. We mention as well that parameters that are
within brackets are implicit. So if we have two terms \id{x} and \id{y} of type
\id{A}, the type representing a path between the two terms is \fn{x $\equiv$ y}.
In order to construct such an equality, we need to construct a function \id{f:I
  $\rightarrow$ A} such that \fn{f i0} is equal to \id{x} and \fn{f i1} is equal
to \id{y}. For example, we construct the reflexive proof of equality.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
refl : {A : Set @$\ell$@} {x : A} @$\rightarrow$@ x @$\equiv$@ x
refl {x = x} = @$\lambda$@ i @$\rightarrow$@ x
\end{minted}

\fn{\{x = x\}} is how we tell \Agda{} that we would like to bind the implicit
argument \id{x} (left) to the variable \id{x} (right) such that it may be used
on the right-hand side. We constructed a constant function that returns \id{x}
and ignores that interval argument \id{i}. This example also illustrates why
explicit pattern matching on \id{i} is not allowed; if we could arbitrarily
assign return values to each endpoint of the interval, we could then prove
equalities between arbitrary terms. To emphasise that the equality proof is
indeed nothing more than a typical function in Agda, we could move the argument
\id{i} to the left-hand side of the equation as would be possible with normal
function arguments.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
refl : {A : Set @$\ell$@} {x : A} @$\rightarrow$@ x @$\equiv$@ x
refl {x = x} i = x
\end{minted}

Although pattern matching is forbidden on interval variables, numerous primitives
act on the interval type, allowing us to manipulate them. We illustrate this with
a proof of the commutativity of equality.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
comm : {A : Type} {x y : A} @$\rightarrow$@ x @$\equiv$@ y @$\rightarrow$@ y @$\equiv$@ x
comm p i = p (~ i)
\end{minted}

Like before, we introduced a new interval variable \id{i} since we are
constructing an equality proof which is simply a function. We also make use of
the fact that the proof \id{p} of \fn{x $\equiv$ y} is also a function, hence we
may freely use function application on it. The primitive operator \id{\~{}}
negates an interval endpoint. We can thus verify that \fn{comm p i0 = y} and
\fn{comm p i1 = x} as required.

Having equality proofs that are based on functions out of the interval type also
allows us to derive the theorem of functional extensionality. This theorem says
that says that functions that are pointwise equal are equal. This is a desirable
property that is not typically provable in Martin-Löf type
theory\cite{martin1975intuitionistic}.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
funext : {A B : Type} {f g : A @$\rightarrow$@ B} @$\rightarrow$@ (@$\forall$@ (a : A) @$\rightarrow$@ f a @$\equiv$@ g a) @$\rightarrow$@ f @$\equiv$@ g
funext p i = @$\lambda$@ x @$\rightarrow$@ p x i
\end{minted}

The proof \id{p} is a witness that the functions \id{f} and \id{g} agree on all
possible input arguments \id{a} of type \id{A}. An example of such a proof could
be constructed for the functions \fn{$\lambda$ x $\rightarrow$ x + 1} and
\fn{$\lambda$ x $\rightarrow$ 1 + x} which are extensionally equal. To prove the
aforementioned theorem, we need to construct a term such that \fn{funext p i0 =
  f} and \fn{funext p i1 = g}. Hence, we construct a lambda function that passes
its argument \id{x} to \id{p} to obtain a proof that \fn{f x $\equiv$ g x}, then
it applies the interval argument \id{i} obtain either \fn{f x} or \fn{g x}.
Summarising the above, \fn{funext p i0 = $\lambda$ x $\rightarrow$ f x} and
\fn{funext p i1 = $\lambda$ x $\rightarrow$ g x}. The $\eta$-equivalence of
functions makes it such that the proof is complete\footnote{For clarity's sake
we did not move the argument \id{x} to the left-hand side of the definition.} as
it implies that \fn{$\lambda$ x $\rightarrow$ f x} is definitionally equal to
\id{f}.

%% The type of paths is the following:

%% \begin{minted}[escapeinside=@@,mathescape=true]{agda}
%% PathP : @$\forall$@ {@$\ell$@} (A : I @$\rightarrow$@ Set @$\ell$@) @$\rightarrow$@ A i0 @$\rightarrow$@ A i1 @$\rightarrow$@ Set @$\ell$@
%% \end{minted}

HITs are a generalisation of inductive types that has been popularised by
homotopy type theory\cite{HoTTbook}. Aside from the usual term constructors of
inductive types, HITs allow the definition of equality constructors,
i.e.\ equalities between terms of the inductive type. Additionally, we are
allowed to define equalities between equalities. HITs provide us with an
expressive and convenient way of defining quotients. For instance, we could
define the type of integers that we previously saw.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
data Int : Type where
  zero : Int
  pred : Int @$\rightarrow$@ Int
  succ : Int @$\rightarrow$@ Int
  predsucc@$\equiv$@id : (n : Int) @$\rightarrow$@ pred (succ n) @$\equiv$@ n
  succpred@$\equiv$@id : (n : Int) @$\rightarrow$@ succ (pred n) @$\equiv$@ n
\end{minted}

Here we define a new type \id{Int}. The first three constructors are known as
\emph{term constructors} and are no different from the constructors that one
defines with normal inductive types. While defining the term constructors, we
may simultaneously define equality constructors\footnote{They are more commonly
known as path constructors in a HoTT setting.} between terms of the inductive
type. The \id{predsucc$\equiv$id} constructor says that for any integer \id{n},
we may construct a proof of (propositional) equality between \fn{pred (succ n)}
and \id{n}, ditto for \id{succpred$\equiv$id}. Not only can we prove such
equalities, but they also have to be respected during elimination. Equality
constructors have to be handled as separate branches when we carry out case
analysis. We illustrate this by constructing a function that negates integers by
recursively switching every \id{pred} to a \id{succ} and vice versa.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
Int-negate : Int @$\rightarrow$@ Int
Int-negate zero = zero
Int-negate (pred n) = succ (Int-negate n)
Int-negate (succ n) = pred (Int-negate n)
Int-negate (predsucc@$\equiv$@id n i) = succpred@$\equiv$@id (Int-negate n) i
Int-negate (succpred@$\equiv$@id n i) = predsucc@$\equiv$@id (Int-negate n) i
\end{minted}

In the first three branches, we say what the function should do to the term
constructors. The last two branches are proof that the function behaves
coherently with respect to the two equality constructors of $\id{Int}$.
According to \fn{predsucc$\equiv$id n}, we know that \fn{pred (succ n)} and
\fn{n} are supposed to be equal. By congruence of equality, the application of
\id{Int-negate} to both sides of this equality should again yield two equal
terms, i.e.\ \fn{succ (pred (Int-negate n))} and \fn{Int-negate n} should be
equal. We can easily construct a proof of this equality by using the term
\fn{succpred$\equiv$id (Int-negate n)}. The other branch that deals with
\fn{succpred$\equiv$id n} may be handled similarly.

We could also define quotient types as formulated by
Hoffman\cite{hofmann1995extensional} as a higher inductive type in \Agda{}.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
data _/_ {l l'} (A : Type l) (R : A @$\rightarrow$@ A @$\rightarrow$@ Type l') : Type (l-max l l')
   where
   [_] : A @$\rightarrow$@ A / R
   eq/ : (a b : A) @$\rightarrow$@ (r : R a b) @$\rightarrow$@ [ a ] @$\equiv$@ [ b ]
\end{minted}

We define the quotient type former \fn{\_/\_} which has two parameters. \id{A}
is the base type of the quotient, and \id{R} a binary relation defined on the
type \id{A}. \fn{[\_]} is a mixfix operator that acts as the only term
constructor of the quotient type; conceptually it acts as the surjection of a
term of the base type into the quotient. \fn{eq/} on the other hand is an
equality constructor that says that if we can provide a witness of \fn{R a b},
i.e.\ a proof that terms \id{a} and \id{b} fulfil the underlying relation of the
quotient, then their surjections into the quotient are also equal.

To illustrate how this works, we present an example of a quotient type in the
form of unordered pairs. The type of pairs is \fn{A $\times$ B} and its terms
have the form \fn{(x , y)}. The concept of unordered pairs is such that \fn{(x ,
  y)} should be equal to \fn{(y , x)}. We thus define a relation on the type of
pairs such that permutations of the elements are equivalent.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
UPairR : @$\forall$@ {l} {A : Type l} @$\rightarrow$@ A @$\times$@ A @$\rightarrow$@ A @$\times$@ A @$\rightarrow$@ Type l
UPairR (x1 , y1) (x2 , y2) = ((x1 @$\equiv$@ x2) @$\times$@ (y1 @$\equiv$@ y2)) @$\uplus$@ ((x1 @$\equiv$@ y2) @$\times$@ (y1 @$\equiv$@ x2))
\end{minted}

$\uplus$ is the type theoretical equivalent of disjunction. We say that two
pairs are equivalent if they are equal element-wise or if by swapping the second
pair we get element-wise equality. With that, we can now define the type of
unordered pairs.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
UnorderedPair : @$\forall$@ {l} @$\rightarrow$@ Type l @$\rightarrow$@ Type l
UnorderedPair A = (A @$\times$@ A) / UPairR
\end{minted}

If we would like to define a map from \fn{UnorderedPair A} to some type \id{B},
intuitively speaking we would require some function \id{f} of type \fn{A
  $\times$ A $\rightarrow$ B} such that it is a commutative function so that the
ordering of the pairs does not matter, i.e.\ that \fn{$\forall$ x y. f x y
  $\equiv$ f y x}. Indeed, we can define the function \id{UPairR-elim} that
captures the above idea.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
UPairR-elim : @$\forall$@ {A B} @$\rightarrow$@ (f : A × A @$\rightarrow$@ B)
              @$\rightarrow$@ ((x y : A) @$\rightarrow$@ f (x , y) @$\equiv$@ f (y , x))
              @$\rightarrow$@ UnorderedPair A @$\rightarrow$@ B
UPairR-elim f h [ p ] = f p
UPairR-elim f h (eq/ (x1 , y1) (x2 , y2) r i) = ?
\end{minted}

Pattern matching on an unordered pair gives us two cases to cover. The \id{[\_]}
constructor is handled easily as we simply pass the pair \id{p} to the function
\id{f}. The branch for the equality constructor on the other hand is more
interesting. The placeholder needs to be equal to \fn{f (x1 , y1)} when \fn{i =
  i0} and it needs to be \fn{f (x2 , y2)} when \fn{i = i1}, in other hands we
need to construct an equality between \fn{f (x1 , y1)} and \fn{f (x2 , y2)} and
apply \id{i} to it. We provide a brief sketch of the proof, it may be
constructed by doing case analysis on \id{r}, a term of type \fn{UPairR (x1 ,
  y1) (x2 , y2)}. In the case of the left injection into the disjunction, we
prove the required equality using the congruence property of equality; in the
other case, we just use the substitution property of equality along with \id{h},
a proof that \id{f} is commutative.

\section{Quotient Haskell}\label{sec:related-qit}

Quotient Haskell is an extension that introduces quotient inductive types to the
Haskell programming language.

Quotient inductive types (QITs) are essentially HITs that are set-truncated.
This essentially provides us with the full range of expressiveness of HITs
without higher-dimensional paths. In other words, the definition of paths
between paths is not allowed. Indeed, such paths are not typically required in
day-to-day programming tasks.

%% SM: Need an example to illustrate what you mean by "arbitrary equation
%% constructors".
Unlike the quotient types that we introduce in this work, QITs allow the
definition of arbitrary equation constructors between terms of an inductive type
instead of requiring these equalities to be encoded as equivalence relations.
This can prove to be very helpful when defining certain quotients. In
\autoref{sec:multiset}, we defined a relation on the \id{List} data type such
that all permutations of a list are considered equivalent. The relation was
slightly tedious to define as we had to be careful to ensure that it was indeed
an equivalence relation by adding appropriate constructors where necessary. A similar
definition in Quotient Haskell\cite{hewer2023quotient} is simpler and more straight
to the point, as is illustrated in the following code block:

%% SM: This is confusing: You say QITs are essentially a restriction of HITs,
%% and this example is within the QIT section, but it looks syntactically
%% different from a (restricted) HIT (e.g. because there is a non-quotiented
%% base type).
\begin{minted}{haskell}
data Multiset a
  = List a
  |/ swap :: x:a -> y:a -> l:Multiset a -> cons x (cons y l) == cons y (cons x l)
\end{minted}

What is important to note here that since we are adding equation constructors,
we do not need the counterparts of the other constructors that were required in
the Typer definition of the relation as they are vacuously valid here by virtue
of the congruence properties of the equality type. This seems to suggest that
%% SM: More convenient than HITs or than QTs?
QITs are more convenient to work with in practice. QITs are also strictly more
expressive than the combination of ordinary inductive types with quotient
types\cite{fiore2022quotients}. However in practice, the additional expressivity
offered by QITs is often unrequired for general programming. The example
provided by the aforementioned paper of a QIT that we may not trivially define
using quotient types in the form of unordered infinitely branching trees is
indeed not a data type that one would expect to make a frequent appearance in
daily programming tasks. Hence, we opted to introduce plain quotient types to
Typer instead of QITs primarily because of its simpler implementation. Aside
from that, we get the added benefit of preserving the modularity of the current
implementation of inductive types.

\section{Quotients in Observational Type Theory}

%% TODO: Be a bit more careful with this section as I'm reading about this for
%% the first time, so I might be prone to misunderstanding the article
%% (pujet2022observational)

In observational type theories such as TT$^{obs}$\cite{pujet2022observational},
every type has a built-in setoid structure which is preserved by all terms by
construction. Equality is represented by the setoid equality of types
themselves, each type is thus free to have its own notion of equality. The
observational equality type is denoted as \fn{t $\sim_A$ u}, this type
represents the equality of terms \id{t} and \id{u} at type \id{A}. However, this
is not a typical type former of equality types as we have previously seen,
$\sim$ in reality pattern matches on the type \id{A} and the two endpoints and
computes to a type. We show two reduction rules to illustrate this point.
First, we show the reduction rule for observational equality between two
propositions. Note that in TT$^{obs}$, $\Omega_i$ is a universe of proof
irrelevant propositions.

\begin{prooftree*}
  \hypo{\oftype{\ctx}{A}{\Omega_i}}
  \hypo{\oftype{\ctx}{B}{\Omega_i}}

  \infer2[\kw{EQ-$\Omega$}]{\oftype{\ctx}{A \sim_{\Omega_i} B \Rightarrow{} (A
      \rightarrow{} B) \wedge{} (B \rightarrow{} A)}{\Omega_i}}
\end{prooftree*}

Observational equality between propositions is simply represented by their
logical equivalence, implying that propositional extensionality is baked into
the theory. Next, we discuss the reduction rule for observational equality
between functions.

\begin{prooftree*}
  \hypo{\oftype{\ctx}{f}{\Pi{} (x:A).B}}
  \hypo{\oftype{\ctx}{g}{\Pi{} (x:A).B}}

  \infer2[\kw{EQ-FUN}]{\oftype{\ctx}{f \sim_{\Pi{} A B} g \Rightarrow{}
      \Pi{} (x:A). \Funapp{f}{x} \sim_B \Funapp{g}{x} }{\Omega_i}}
\end{prooftree*}

We observe that observational equality between functions simply reduces to a
proof of pointwise equality of these functions, in other words, functional
extensionality is built into the system.

All that to say that this system lends itself well to the introduction of
quotient types. The quotient type \fn{A/R} is interpreted as a setoid with
\id{A} as its base type and the relation \id{R} as its setoidal equality. This
of course requires the relation \id{R} to be reflexive, symmetric and
%% SM: "surjections" -> "projected"?
transitive. In the theory, equality between two terms that are surjections into
the quotient (this is syntactically represented by $\pi(t)$) reduces to the
underlying relation between the base terms, as is illustrated by the following
rule:

%% SM: This OITT section should maybe be a bit more careful to compare OTT
%% to your work (and a bit less about presenting OTT in general).
%% The rule below is directly relevant, which is good.
%% But what's missing is for example what the elimination form looks like.

\begin{prooftree*}
  \hypo{\oftype{\ctx}{t}{A}}
  \hypo{\oftype{\ctx}{u}{A}}

  \infer2{\oftype{\ctx}{\pi(t) \sim_{A/R} \pi(u) \Rightarrow{} \Funapp{R}{t}{u}
    }{\Omega_i}}
\end{prooftree*}


\section{Setoid Rewriting}

Quotient types are not provided as a primitive in the \Coq{} proof assistant.
%% SM: "that" being...?
Before we get to that, we briefly introduce the rewriting mechanism of \Coq{}.
Every construction is congruent with respect to the equality type, hence
rewrites using the equality type may be carried out in any context. For
instance, if we have a certain proof goal that requires us to produce a term of
type \fn{m + n $\le$ n + m} and we have proof that \fn{m + n $\equiv$ n + m}, we
may use the \kw{rewrite} tactic in \Coq{} to rewrite the goal such that it
becomes \fn{n + m $\le$ n + m}. The simplified goal may thus be easily proven
using the reflexivity property of $\le$.

Plain rewriting allows rewriting with \emph{equal} terms, generalised
rewriting\cite{sozeau2009new, coq-gen-rewriting} on the other hand enables
rewriting using terms that are \emph{related} by some binary relation , often
represented as a function of type \fn{A $\rightarrow$ A $\rightarrow$
  \kw{Prop}}. Unlike equality, this form of rewriting does not work in all
contexts, instead it only works in contexts that are compatible with the
relation. A base type \id{A} equipped with an equivalence relation that is meant
to behave as an equality characterises a structure known as a
setoid\cite{hofmann1995simple}. Instead of constructing a new type to represent
the quotient of the base type, we would directly work with the base type.
Suppose that we had a proof of \fn{a R b} where \id{R} is a binary relation, we
would be able to rewrite \id{a} to \id{b} if the context of \id{a} in the goal
is compatible with the relation. However, every function definition that
interacts with the setoid needs to be accompanied with a proof that setoid
equivalence is respected. This is in contrast to the ideal situation where such
coherence proofs are \emph{only} required in the function that eliminates
quotients, subsequent interaction, and composition of this function should be
%% SM: "This has historically...": not clear whether "This" refers to setoid
%% rewriting or to "the ideal situation".
free of the burden of such proof obligations. This has historically been the
go-to way of modelling quotient types in \Coq{}, however such an approach is
known to be rather laborious. This phenomenon is often designated as
\emph{setoid hell} by the community\footnote{Examples of community discussions
on this topic may be found at
\url{https://stackoverflow.com/questions/65493694/why-do-calculus-of-construction-based-languages-use-setoids-so-much/}
and
\url{https://proofassistants.stackexchange.com/questions/908/what-exactly-is-setoid-hell/}}.
Although \Coq{} offers numerous tactics to facilitate the usage of setoids, it
quickly becomes unwieldy in the case of large programs.

\chapter{Evaluation}

At the start of this work, we first set out to augment Typer with a more
powerful and expressive notion of equality. We achieved this by basing our new
equality type on an Interval type. We showed the benefits of such an equality
type by demonstrating that the manipulation of propositional equality is greatly
simplified. To that end, we illustrated the derivation of various
equality-related theorems in a clean and elegant manner. Some desirable
properties such as functional extensionality that we are now able to derive were
previously unprovable by using Typer's original equality type.

We then introduced quotient types to Typer. We convinced ourselves that our
quotient types behave as they should by proving that they fulfil the universal
property of quotients. A library was provided with proofs of many other
properties fulfilled by our quotient types. We also explored the practical
aspects of our quotient types by using them to construct several examples. We
then observed that when the identifications that we wish to impose on the base
type may be immediately represented as an equivalence relation, the resulting
construction was a lot simpler as was the case with \id{Rational}. However, our
experience constructing \id{Multiset} showed that when the identifications that
we require do not immediately induce an equivalence relation, we need to
manually construct the reflexive, symmetric, and transitive closure of the
resulting relation. This complicates the underlying relation of the quotient,
leading to additional proof obligations that are often easily satisfied but
unnecessary. This may be seen as a glaring disadvantage of our approach as
opposed to quotient inductive types that allow the direct definition of path
constructors on inductive types.

The introduction of \id{Quotient\_eq} as an axiom also leads to the absence of a
desirable computational property. Suppose that the following terms \fn{a : A},
\fn{a' : A}, and \fn{r : R a a'} as well as a function \fn{f : A $\rightarrow$
  B} and a proof that it respects the relation \id{R}, i.e.\ \fn{p : (a a' : A)
  $\rightarrow$ R a a' $\rightarrow$ f a $\equiv$ f a'}. Unfortunately, the
following equality does not hold definitionally \fn{Eq\_cong (Quotient\_rec f (p
  := p)) (Quotient\_eq r) $\equiv$ p a a' r}. This would indeed be a
definitional equality in Cubical Agda if we were to use the construction that
was shown in \autoref{sec:cubical-agda}. However, it was not clear to us how the
same could be done in Typer as it would involve the hard coding of this
equivalence in an ad hoc manner.

As the examples in the previous sections would suggest, the usage of quotient
types is often accompanied by a considerable amount of proof obligations. As we
have seen, such proofs are not always trivial to construct, mainly because of
Typer's current lack of support for the development of proofs as opposed to
other contemporary programming languages. For instance, the Quotient Haskell
extension\cite{hewer2023quotient} is implemented with the help of Satisfiability
Modulo Theories (SMT) solvers. This enables many proof obligations generated by
quotient types to be satisfied automatically. In other words, most of the proofs
that we had to write by hand in \autoref{ch:quot-examples} while constructing
the types \id{Rational} and \id{Multiset} could have been solved automatically
without too much hassle. The proof development experience can also be contrasted
to interactive proof assistants that feature tactics such as \Coq{} and \Lean{}.
Tactics generally allow us to write our proofs in a less verbose manner by
preventing unnecessary repetition. Most of our long chains of equational
reasoning involved the repeated application of the congruence property of
equality. This is analogous to the usage of the \emph{rewrite} tactics of the
aforementioned proof assistants with the difference that invocation of
\id{Eq\_cong} requires us to manually specify the context in which the rewrite
should occur. The more verbose proofs are indeed more readable, however, it makes
their development a laborious endeavour. During the construction of
\id{Rational}, we had to do a lot of monotonous reasoning related to linear
arithmetic to prove propositions that were seemingly obvious to the
human eye. Such goals may typically be solved using tactics such as the \Coq{}'s
\kw{lia} tactic and \Lean{}'s \kw{linarith} tactic that are essentially solvers
for linear goals over $\mathbb{Z}$. For the moment, Typer also lacks the
powerful dependent pattern-matching system of \Agda{}. This inconvenience is
somewhat mitigated by the presence of the \fn{\kw{case} $\ldots$ \kw{as}
  $\ldots$ \kw{return} $\ldots$} construct that is reminiscent of \Coq{}.
However, while we are in \kw{case} branches, we lack the specialisation of types
of other variables in the context that depend on the scrutinee. This was an
inconvenience that we had to reckon with on numerous occasions while working
with quotient types. The above seems to be desirable features that we should
contemplate introducing to Typer in some shape or form to facilitate proof
development.

\section*{Benchmarks}\label{sec:quot-benchmark}

In this section, we use our implementation of \id{Rational} and \id{Multiset} to
explore the runtime cost of using quotient types in Typer. Quotient types are
nothing more than a means of using the type system to ensure that programmers
respect a certain relation on a base type by means of proof obligations. Such
proofs can be expected to be erased before the actual execution of a program.
Our intuition thus tells us that it should be feasible to have quotient types as
a zero-cost abstraction in our system. The tests in our benchmark were designed
with the simple objective of verifying the above claim.

\subsection*{Rational}

Since the operations on rational numbers are essentially wrappers around
operations on the base type $\zpair$, our benchmark simply compares the
execution time of operations on $\zpair$ with their $\fn{Rational}$
counterparts\footnote{The code for this may be found in the
$\fn{rational\_benchmark.typer}$ file.}. We examine the runtime
cost\footnote{The tests were executed on the author's 2018 Macbook Pro with a
quadcore 2.3GHz Intel Core i5 processor with 8GB of RAM.} of executing the
functions $\fn{Rational\_negate}$, $\fn{Rational\_+}$, $\fn{Rational\_-}$ and
$\fn{Rational\_*}$ on 500000 pairs of rational numbers.

%% TODO: Column sizes aren't equal between zpair and Rational? How do I fix this?
\begin{table}[H]
\centering
\begin{tabular}{ccccc}
\hline
\multirow{2}{*}{\textbf{Operation}} & \multicolumn{2}{c}{\textbf{Execution Time (seconds)}} & \multicolumn{2}{c}{\textbf{Overhead}} \\ \cline{2-5}
                                    & \textbf{$\zpair$}          & \textbf{Rational}         & \textbf{seconds}     & \textbf{\%}    \\ \hline
Negation       & 1.82 & 2.53 & 0.71 & 39.0 \\
Addition       & 3.18 & 4.82 & 1.64 & 51.6 \\
Subtraction    & 4.10 & 6.26 & 2.16 & 52.7 \\
Multiplication & 2.97 & 4.59 & 1.62 & 54.5 \\ \hline
\end{tabular}
\caption{The runtime cost of operations on rational numbers with and without the
  use of quotient types.}\label{tab:rational-benchmark}
\end{table}

We observe that there is indeed a non-negligible overhead caused by the usage of
quotient types, which we will now try to justify. Without loss of generality, we
discuss the addition operation. Once the $\zpairplus$ function that handles the
addition of $\zpair$ and its $\fn{Rational}$ counterpart, $\fn{Rational\_+}$
have undergone erasure, the resulting functions are extensionally equal. By
definition of erasure\cite{monnier2019typer}, all erasable arguments are
removed, hence all proof objects required by the quotient type will be absent in
the erased versions of the above functions. The two erased functions are
nevertheless not completely equal, as we shall see by examining the Elexp
(erased lambda expression)\cite{delaunay2017implementation} of
$\fn{Rational\_+}$:

\begin{minted}[escapeinside=@@,mathescape=true]{scheme}
(lambda (a) @$\rightarrow$@ (lambda (b) @$\rightarrow$@
  (Quotient_rec2 (lambda (x) @$\rightarrow$@
                     (lambda (y) @$\rightarrow$@
                         (@$\zpairplus$@ x y))) a b)))
\end{minted}

Through a series of $\eta$-reductions and $\beta$-reductions, we can see that
the above expression is equivalent to $\zpairplus$. This implies that with an
appropriate optimisation phase, Elexps containing quotient primitives could be
simplified to completely neutralise the overhead of quotient types. We leave
this optimisation for future work. We also note that addition and
multiplication unsurprisingly have a similar constant overhead due to how
similarly they are defined. Since negation is a unary operation, it
was defined directly using $\fn{Quotient\_rec}$ and thus has a lesser overhead
than the other binary operations. We also defined subtraction based on
addition combined with subtraction, so its greater overhead is well justified.

\subsection*{Multiset}

We do a similar set of experiments on our construction of \id{Multiset} with the
\id{Multiset\_append} and \id{Multiset\_mem} operations.

% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
% \usepackage{multirow}
\begin{table}[H]
\centering
\begin{tabular}{@{}lllll@{}}
\toprule
\multirow{2}{*}{\textbf{Operation}} & \multicolumn{2}{l}{\textbf{Execution Time (seconds)}} & \multicolumn{2}{l}{\textbf{Overhead}} \\ \cmidrule(l){2-5}
       & \textbf{List} & \textbf{Multiset} & \textbf{seconds} & \textbf{\%} \\ \midrule
Append & 4.46          & 4.95              & 0.49             & 11.0        \\
Member & 0.28          & 0.33              & 0.05             & 17.8        \\ \bottomrule
\end{tabular}
\caption{The runtime cost of operations on multisets with and without the use of quotient types.}
\label{tab:benchmark-multiset}
\end{table}

The \id{Multiset\_append} operation was tested by appending multisets of 100
integers with themselves 50000 times. For the \id{Multiset\_mem} operation, we
ran the membership test with 50 integers on a multiset containing 100 integers,
this was repeated 1000 times.

%% TODO: If the number of `operations' is the same across both experiments, then
%% why is the overhead for 'member' significantly less? I either screwed up the
%% tests or I'm misinterpreting this?

We also observe that the generated Elexps for \id{Multiset\_append} and
\id{Multiset\_mem} are devoid of their related proof terms. \id{Quotient\_rec}
and \id{Quotient\_rec2} both reduce to the application of the lambda passed to
it on the subsequent arguments.

\begin{figure}[H]
\begin{minted}[escapeinside=@@,mathescape=true]{scheme}
(lambda (xs) ->
 (lambda (ys) ->
  (Quotient_rec2 (List_append) xs ys)))
\end{minted}
\caption{Elexp of \id{Multiset\_append}}
\end{figure}

\begin{figure}[H]
\begin{minted}[escapeinside=@@,mathescape=true]{scheme}
(lambda (disc) ->
 (lambda (a) ->
  (lambda (s) ->
   (Quotient_rec (lambda (l) ->
                  (Dec2Bool (isMemberDec disc a l))) s))))
\end{minted}
\caption{Elexp of \id{Multiset\_mem}}
\end{figure}

\chapter{Conclusion}

\ldots


\ldots

%%--------------%
%%     index    %
%%--------------%

%% S'il y a lieu, décommenter la ligne pour mettre votre index

%%\printindex

%%------------------------------------------------- %
%%         références --- bibliographie             %
%%------------------------------------------------- %

\def\bibname{References}
\bibliography{main}
\bibliographystyle{ieeetr}



%%------------------------------------------------- %
%%                  Annexe A                        %
%%------------------------------------------------- %

\anglais
\appendix

\chapter{Equational Reasoning}\label{section:eqreasoning}
Equational reasoning provides us with a neat way of expressing proofs in Typer.
With the help of some syntactic sugar, this allows us to build chains of
equality proofs by using the transitivity property of equality as shown in
Section~\ref{subsection:eqtransitivity}. This is something that is implemented
in the libraries of most proof assistants, such as \Agda{}, and \Lean{}. This
allows lengthy proofs to remain readable as intermediate steps are documented
and are clearly seen.

First, we introduce a helper function that simply invokes the transitivity
property of equality proofs. This function carries out a single step of
equational reasoning.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
step-@$\equiv$@ : (x : ?A) @$\rightarrow$@ (y : ?A) @$\rightarrow$@ (z : ?A) @$\rightarrow$@ Eq x y @$\rightarrow$@ Eq y z @$\rightarrow$@ Eq x z
step-@$\equiv$@ _ p q = Eq_trans p q
\end{minted}

Next, we require a second function to conclude a chain of equational reasoning.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
qed : (x : ?A) @$\rightarrow$@ Eq x x
qed x = Eq_refl
\end{minted}

To make it all come together, we wrap the above functions with some syntactic
sugar.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
_==<_>==_ = step-@$\equiv$@
_@$\qed$@ = qed
\end{minted}

\verb|_==<_>==_| can be seen as a mixfix operator, whereas \_$\qed$ is a postfix
operator.

When we write the following

\begin{lstlisting}
  x
  ==< p >==
  y
  ==< ... >==
  .
  .
  .
  ==< ... >==
  z $\qed$
\end{lstlisting}

We require that $\id{p}$ be a proof of equality between $\id{x}$ and $\id{y}$, and this can be chained \latinphrase{ad infinitum}. The expression in its entirety is a proof of equality between $\id{x}$ and $\id{z}$. The usage of this is best illustrated via a simple example:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
example : (x : ?A) @$\rightarrow$@ (y : ?A) @$\rightarrow$@ (z : ?A) @$\rightarrow$@ (w : ?A)
          @$\rightarrow$@ (p : Eq x y) @$\rightarrow$@ (q : Eq y z) @$\rightarrow$@ (r : Eq z w) @$\rightarrow$@ Eq x w
example x y z w p q r =
  x ==< p >==
  y ==< q >==
  z ==< r >==
  w @$\qed$@
\end{minted}

For a more involved example, we rewrite the proof of \verb|Integer_*DistR+| that was shown in Section~\ref{subsection:int-theorems} by using equational reasoning.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Integer_*DistR+ : (x : Integer) @$\rightarrow$@ (y : Integer) @$\rightarrow$@ (z : Integer)
                  @$\rightarrow$@ Eq (Integer_* x (Integer_+ y z))
                        (Integer_+ (Integer_* x y) (Integer_* x z))
Integer_*DistR+ x y z =
  Integer_* x (Integer_+ y z)
  ==< Integer_*-comm x (Integer_+ y z) >==
  Integer_* (Integer_+ y z) x
  ==< Integer_*DistL+ y z x >==
  Integer_+ (Integer_* y x) (Integer_* z x)
  ==< Eq_cong (flip Integer_+ (Integer_* z x)) (Integer_*-comm y x) >==
  Integer_+ (Integer_* x y) (Integer_* z x)
  ==< Eq_cong (Integer_+ (Integer_* x y)) (Integer_*-comm z x) >==
  Integer_+ (Integer_* x y) (Integer_* x z) @$\qed$@
\end{minted}

\chapter{Other proofs}\label{app:other-proofs}

\section{Commutativity of addition of natural numbers}

We first define the type of natural numbers along with the addition operation
the usual way.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Nat : Type

type Nat
  | zero
  | succ Nat

_+_ : Nat @$\rightarrow$@ Nat @$\rightarrow$@ Nat
_+_ x y = case x
  | zero @$\Rightarrow$@ y
  | succ m @$\Rightarrow$@ succ (m + y)
\end{minted}

We then define two lemmas that we ultimately use to prove the commutativity of
addition.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Nat+_zero : (m : Nat) @$\rightarrow$@ Eq (m + zero) m
Nat+_zero m =
  case m return Eq (m + zero) m
         | zero @$\Rightarrow$@ Eq_refl
         | succ n @$\Rightarrow$@ Eq_cong succ (Nat+_zero n)

Nat+_succ : (m : Nat) @$\rightarrow$@ (n : Nat) @$\rightarrow$@ Eq (m + succ n) (succ (m + n))
Nat+_succ m n =
  case m return Eq (m + succ n) (succ (m + n))
         | zero @$\Rightarrow$@ Eq_refl
         | succ m' @$\Rightarrow$@ Eq_cong succ (Nat+_succ m' n)

Nat+_comm : (m : Nat) @$\rightarrow$@ (n : Nat) @$\rightarrow$@ Eq (m + n) (n + m)
Nat+_comm m n =
  case n return Eq (m + n) (n + m)
         | zero @$\Rightarrow$@ Nat+_zero m
         | succ n' @$\Rightarrow$@ Eq_trans (Nat+_succ m n')
                               (Eq_cong succ (Nat+_comm m n'))
\end{minted}


\section{Properties of dependent pairs}\label{app:deppairs-properties}
The type of dependent pairs in Typer is represented by the \id{Sigma} inductive
type.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
type Sigma (A : Type) (B : A @$\rightarrow$@ Type)
  | sigma (fst : A) (snd : B fst);
\end{minted}

$\eta$-equivalence does not hold definitionally for the \id{Sigma} type, however
it may be proven propositionally:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
Sigma_@$\eta$@ : (l : TypeLevel) @$\Rrightarrow$@ (A : Type_ l) @$\Rrightarrow$@ (P : (a : A) @$\rightarrow$@ Type_ l)
          @$\Rrightarrow$@ (p : Sigma A P) @$\rightarrow$@ Eq p (sigma (B := P) p.fst p.snd)
Sigma_@$\eta$@ p = case p
    | sigma x y =>
        let
          sigmaxy = sigma (B := P) x y
          branch=p : Eq sigmaxy p
          branch=p = ##DeBruijn 0
          sigmaxy_@$\eta$@ : Eq sigmaxy (sigma (B := P) sigmaxy.fst sigmaxy.snd)
          sigmaxy_@$\eta$@ = Eq_refl
        in
          Eq_cast (p := branch=p)
                  (f := @$\lambda$@ x @$\rightarrow$@ Eq x (sigma (B := P) x.fst x.snd))
                  sigmaxy_@$\eta$@
\end{minted}

We also define a lemma, \id{$\Sigma${}$\equiv${}Prop}, which states that to
prove that two terms of type \fn{Sigma A B} are equal, if \fn{$\Pi_{x:A}$ isProp
  (B x)} is true, then it suffices to show that the first projection of the two
dependent pairs are equal. The proof of this lemma is as follows:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
@$\Sigma$@@$\equiv$@Prop : (A : Type_ ?l1) @$\Rrightarrow$@ (B : (a : A) @$\rightarrow$@ Type_ ?l2)
         @$\Rrightarrow$@ ((x : A) @$\rightarrow$@ HoTT_isProp (B x))
         @$\rightarrow$@ (u : Sigma A B) @$\rightarrow$@ (v : Sigma A B)
         @$\rightarrow$@ (p : Eq u.fst v.fst) @$\rightarrow$@ Eq u v
@$\Sigma$@@$\equiv$@Prop = @$\lambda$@ l1 l2 A B @$\Rrightarrow$@ @$\lambda$@ propB u v p @$\rightarrow$@
  let
    h : Heq (t := lambda i @$\Rrightarrow$@ B (Eq_uneq (p := p) (i := i)))
            u.snd (Eq_cast (p := p) (f := B) u.snd)
    h = Heq_eq (t := @$\lambda$@ i @$\Rrightarrow$@ B (Eq_uneq (p := p) (i := i)))
               (f := @$\lambda$@ i @$\Rrightarrow$@
                      I_transp (A := @$\lambda$@ j @$\Rrightarrow$@ B (Eq_uneq (p := p) (i := I_meet i j)))
                               (r := I_not i) u.snd)
    sndv_eq : Eq (Eq_cast (p := p) (f := B) u.snd) v.snd
    sndv_eq = propB v.fst (Eq_cast (p := p) (f := B) u.snd) v.snd
    pathOver : Heq (t := lambda i @$\Rrightarrow$@ B (Eq_uneq (p := p) (i := i)))
                   u.snd v.snd
    pathOver = whiskerRight (A := @$\lambda$@ i @$\Rrightarrow$@ B (Eq_uneq (p := p) (i := i)))
                            u.snd (Eq_cast (p := p) (f := B) (u.snd))
                            v.snd h sndv_eq
    r : Eq (sigma (B := B) u.fst u.snd) (sigma (B := B) v.fst v.snd)
    r = Eq_eq (f := @$\lambda$@ i @$\Rrightarrow$@
                    sigma (B := B) (Eq_uneq (p := p) (i := i))
                            (Heq_uneq (t := @$\lambda$@ j @$\Rrightarrow$@
                                            B (Eq_uneq (p := p) (i := j)))
                            (p := pathOver) (i := i)))
  in
    Eq_trans (Sigma_@$\eta$@ u) (Eq_trans r (Eq_comm (Sigma_@$\eta$@ v)))
\end{minted}

The above proof makes use of the \id{whiskerRight} lemma which states that if we
have a heterogeneous equality proof between \id{a0} and \id{a1} and a
homogeneous equality proof between \id{a1} and \id{a2}, then we can construct a
heterogeneous equality proof between \id{a0} and \id{a2}. The proof is as
follows:

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
whiskerRight : (A : I @$\Rrightarrow$@ Type_ ?) @$\Rrightarrow$@ (a0 : A (_ := i0)) @$\rightarrow$@ (a1 : A (_ := i1))
               @$\rightarrow$@ (a2 : A (_ := i1)) @$\rightarrow$@ Heq a0 a1 @$\rightarrow$@ Eq a1 a2 @$\rightarrow$@ Heq a0 a2
whiskerRight = @$\lambda$@ l A @$\Rrightarrow$@ @$\lambda$@ a0 a1 a2 p1 p2 @$\rightarrow$@
  Eq_cast (p := p2) (f := @$\lambda$@ x @$\rightarrow$@ Heq (t := A) a0 x) p1
\end{minted}

\section{UMP of Quotients}\label{app:ump-quot}

In order to prove that the universal property of quotients is indeed respected by our
implementation of quotients types in Typer, we need to prove the following:

\begin{align*}
  & (X/R \rightarrow Y) \simeq \Sigma \ (X \rightarrow Y) \ (\lambda \ f \rightarrow (x \ y : X) \rightarrow \Funapp{R}{x}{y} \rightarrow \Funapp{f}{x} \equiv \Funapp{f}{y}) \\
\end{align*}

To construct the forward direction of this equivalence, the function of type
\fn{A $\rightarrow$ B} may be formed by pre-composing the function \fn{f:
  Quotient A R $\rightarrow$ B} with a surjection into the quotient. The
coherence property follows naturally as a consequence of the fact that elements
of the base type that are related under the relation are \emph{equal} after
their surjection into the quotient.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
e : (A : Type) @$\Rrightarrow$@ (B : Type) @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type)
    @$\Rrightarrow$@ (Quotient A R @$\rightarrow$@ B)
    @$\rightarrow$@ Sigma (A @$\rightarrow$@ B)
             (@$\lambda$@ g @$\rightarrow$@ (a : A) @$\rightarrow$@ (a' : A) @$\rightarrow$@ R a a' @$\rightarrow$@ Eq (g a) (g a'))
e = @$\lambda$@ A B R @$\Rrightarrow$@ @$\lambda$@ f @$\rightarrow$@
      sigma (@$\lambda$@ x @$\rightarrow$@ f (Quotient_in (R := R) x))
            (@$\lambda$@ x y r @$\rightarrow$@ Eq_cong f (Quotient_eq (R := R) r))
\end{minted}

As for the reverse direction, we are required to construct a map from
\fn{Quotient A R} to \id{B}. To that end, we can simply apply the function of
type \fn{A $\rightarrow$ B} to the underlying element of the quotient.
Conceptually speaking, this function merely strips away the \id{Quotient\_in}
and may be regarded as a trivial right inverse to the pre-composition with
\id{Quotient\_in}.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
e' : (A : Type) @$\Rrightarrow$@ (B : Type) @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type)
     @$\Rrightarrow$@ Sigma (A @$\rightarrow$@ B)
              (@$\lambda$@ g @$\rightarrow$@ (a : A) @$\rightarrow$@ (a' : A) @$\rightarrow$@ R a a' @$\rightarrow$@ Eq (g a) (g a'))
     @$\rightarrow$@ (Quotient A R @$\rightarrow$@ B)
e' = @$\lambda$@ A B R @$\Rrightarrow$@ @$\lambda$@ s @$\rightarrow$@ Quotient_rec (R := R) s.fst (p := s.snd)
\end{minted}

Now it remains to prove that \id{e} and \id{e'} are both left and right inverses
of each other. \fn{e' $\circ{}$ e $\equiv$ id} is proved without too much hassle
by using functional extensionality and the fact that the output type \id{B} is a
Set.

\begin{minted}[escapeinside=@@,mathescape=true]{haskell}
e'e=id : (A : Type) @$\Rrightarrow$@ (B : Type) @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type)
         @$\Rrightarrow$@ HoTT_isSet B
         @$\rightarrow$@ (f : Quotient A R @$\rightarrow$@ B)
         @$\rightarrow$@ Eq (e' (R := R) (e f)) f
e'e=id = @$\lambda$@ A B R @$\Rrightarrow$@ @$\lambda$@ isSetB f @$\rightarrow$@
  let
    p : (x : Quotient A R) @$\rightarrow$@ (f : Quotient A R @$\rightarrow$@ B)
        @$\rightarrow$@ Eq (e' (R := R) (e f) x) (f x)
    p x f =
      quot_lib.elimProp
          (R := R)
          (P := @$\lambda$@ x @$\rightarrow$@ Eq (e' (R := R) (e f) x) (f x))
          (@$\lambda$@ x @$\rightarrow$@ isSetB (e' (R := R) (e f) x) (f x))
          (@$\lambda$@ x @$\rightarrow$@ Eq_refl (x := f (Quotient_in (R := R) x)))
          x
  in
    HoTT_lib.Eq_funext (f := e' (R := R) (e f)) (g := f) (@$\lambda$@ x @$\rightarrow$@ p x f)
\end{minted}

Although it was mentioned earlier that \id{e'} is a trivial right inverse of
\id{e}, implying that \fn{e $\circ{}$ e' $\equiv$ id} should be able to proved
by reflexivity, some limitations of Typer make this unfeasible for the moment.
One of the reasons is because the $\eta$-equivalence of \id{Sigma} does not hold
definitionally as mentioned in \autoref{app:deppairs-properties}, though it may
be proven propositionally.

Another thing that we are lacking is a proof that the dependent map induced by
\id{Quotient\_rec} and \id{Quotient\_eq} is coherent. Suppose that we had terms
\fn{x y:A}, \fn{r:R x y} and a function \fn{f:A $\rightarrow$ B} as well as a
proof \id{p} that \id{f} respects the quotient, i.e.\ \fn{p: (a:A) $\rightarrow$
  (a':A) $\rightarrow$ R a a' $\rightarrow$ f a $\equiv$ f a'}. Then we could
expect the below coherence property to hold:

\begin{align*}
  & \fn{Eq\_cong (Quotient\_rec f (p := p)) (Quotient\_eq r)} \equiv \fn{p x y} \\
\end{align*}

This property does not hold definitionally in Typer, however we could prove it
by appealing to the fact that the output type \id{B} is a \textbf{Set}. In our
proof of \fn{e $\circ{}$ e' $\equiv$ id}, we shall make use of both of the above
properties manually by invoking the \id{$\Sigma$$\equiv$Prop} lemma defined in
\autoref{app:deppairs-properties}. The lemma allows us to construct a short and
elegant proof of \fn{e $\circ{}$ e' $\equiv$ id}.

\begin{minted}[escapeinside=@@,mathescape=true]{agda}
ee'=id : (A : Type) @$\Rrightarrow$@ (B : Type) @$\Rrightarrow$@ (R : A @$\rightarrow$@ A @$\rightarrow$@ Type)
         @$\Rrightarrow$@ HoTT_isSet B
         @$\rightarrow$@ (p : Sigma (A @$\rightarrow$@ B)
                       (@$\lambda$@ g @$\rightarrow$@ (x : A) @$\rightarrow$@ (y : A) @$\rightarrow$@ R x y @$\rightarrow$@ Eq (g x) (g y)))
         @$\rightarrow$@ Eq (e (e' (R := R) p)) p
ee'=id = @$\lambda$@ A B R @$\Rrightarrow$@ @$\lambda$@ isSetB p @$\rightarrow$@
  let
    propSnd g =
      HoTT_lib.isProp@$\Pi$@
        (B := @$\lambda$@ x @$\rightarrow$@ (y : A) @$\rightarrow$@ R x y @$\rightarrow$@ Eq (g x) (g y))
        (@$\lambda$@ x @$\rightarrow$@ HoTT_lib.isProp@$\Pi$@
                  (B := @$\lambda$@ y @$\rightarrow$@ R x y @$\rightarrow$@ Eq (g x) (g y))
                  (@$\lambda$@ y @$\rightarrow$@ HoTT_lib.isProp@$\Pi$@
                            (B := @$\lambda$@ (r : R x y) @$\rightarrow$@ Eq (g x) (g y))
                            (@$\lambda$@ r @$\rightarrow$@ isSetB (g x) (g y))))
  in
    @$\Sigma$@@$\equiv$@Prop
      (B := @$\lambda$@ g @$\rightarrow$@ (x : A) @$\rightarrow$@ (y : A) @$\rightarrow$@ R x y @$\rightarrow$@ Eq (g x) (g y))
      propSnd
      (e (e' (R := R) p)) p Eq_refl
\end{minted}

This concludes the proof of the desired equivalence.

\chapter{Les différentes parties et leur ordre d'apparition}

%% TODO: Don't forget to ultimately remove this!

J'ajoute ici les différentes parties d'un mémoire ou d'une thèse ainsi
que leur ordre d'apparition tel que décrit dans le guide de
présentation des mémoires et des thèses de la Faculté des études
supérieures.  Pour plus d'information, consultez le guide sur le site
web de la facutlé (www.fes.umontreal.ca).

\newcount\colnum
\colnum=1
\def\i{\number\colnum. \global\advance\colnum by 1\ignorespaces}
\begin{table}[p]
  \begin{center}
    \begin{tabular}{|l|l|r|}\hline
       \noindent\hfil
         \textbf{\strut Ordre des éléments constitutifs du mémoire ou de la thèse}
         \hfil\span\omit\span\omit\\\hline % \span\omit pour couvrir plus d'une
                                           % case sans utiliser le package multirow ou autre
      \i &  La page de titre & obligatoire\\\hline
      \i &  La page d'identification des membres du jury & obligatoire\\\hline
      \i &  Le résumé en français et les mots clés français\kern3em& obligatoires\\\hline
      \i &  Le résumé en anglais et les mots clés anglais & obligatoires\\\hline
      \i &  Le résumé dans une autre langue que l'anglais & obligatoire \\
         &  ou le français (si le document est écrit dans &\\
         &  une autre langue que l'anglais ou le français)&\\\hline
      \i &  Le résumé de vulgarisation& facultatif\\\hline
      \i &  La table des matières, la liste des tableaux,& obligatoires\\
         &   la liste des figures ou autre &\\\hline
      \i &  La liste des sigles et des abréviations& obligatoire\\\hline
      \i &  La dédicace& facultative\\\hline
      \i &  Les remerciements & facultatifs\\\hline
      \i &  L'avant-propos & facultatif\\\hline
      \i &  Le corps de l'ouvrage& obligatoire\\\hline
      \i &  Les index& facultatif\\\hline
      \i &  Les références bibliographiques & obligatoires\\\hline
      \i &  Les annexes & facultatifs\\\hline
      \i &  Les documents spéciaux & facultatifs\\\hline
    \end{tabular}
  \end{center}
\end{table}

\end{document}

\endinput
%%
%% End of file `gabaritmem.tex'.
